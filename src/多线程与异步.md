# Rust的两种异步编程模型

标准库中的两种，可能会有第三方库实现其他模型

## async/await

- 在遇到阻塞操作（如IO）时会让出当前线程的所有权，而非阻塞当前线程，允许该线程继续去执行其他代码，最终实现并发
- 创建、切换线程效率显著更高
- 社区支持时常更新
- 底层实现非常复杂，会导致编译后文件体积显著增加
- **使用开销为0**，可以无需分配任何堆内存、也无需任何动态分发来使用 `async` ，这对于热点路径的性能有非常大的好处。
- 底层是基于线程封装了一个运行时实现，可以将多个任务映射到少量线程上，然后将线程切换变成了任务切换，后者是访问内存，因此更高效。但是 `async` 模型和多线程模型仍有各自使用场景。

## 多线程

# 使用场景

有时也会两个结合一起使用

## 选用 `async`

- 有**大量 `IO` 任务**需要并发运行时

## 选用多线程

- 有**部分 `IO` 任务**需要并发运行时，选多线程，如果想要降低线程创建和销毁的开销，可以使用线程池
- 有**大量 `CPU` 密集任务**需要并行运行时，例如并行计算，选多线程模型，且让线程数等于或者稍大于 `CPU` 核心数
- 无所谓时，统一选多线程

# 执行器 Executor

Rust 的 `Future` 是惰性的：

- 内部推动的方式：在 `async` 函数中使用 `.await` 来调用另一个 `async` 函数
- 外部推动的方式：需要执行器 `executor` 管理一批 `Future` (最外层的 `async` 函数)，然后通过不停地 `poll` 推动它们直到完成。 最开始，执行器会先 `poll` 一次 `Future` ，后面就不会主动去 `poll` 了，而是等待 `Future` 通过调用 `wake` 函数来通知它可以继续，它才会继续去 `poll` 。这种 **wake 通知然后 poll** 的方式会不断重复，直到 `Future` 完成。

# async move

`async` 允许我们使用 `move` 关键字来将环境中变量的所有权转移到语句块内，就像闭包那样，好处是你不再发愁该如何解决借用生命周期的问题，坏处就是无法跟其它代码实现对变量的共享：

```rust
// 多个不同的 `async` 语句块可以访问同一个本地变量，只要它们在该变量的作用域内执行
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{my_string}");
    };

    let future_two = async {
        // ...
        println!("{my_string}");
    };

    // 运行两个 Future 直到完成
    let ((), ()) = futures::join!(future_one, future_two);
}



// 由于 `async move` 会捕获环境中的变量，因此只有一个 `async move` 语句块可以访问该变量，
// 但是它也有非常明显的好处： 变量可以转移到返回的 Future 中，不再受借用生命周期的限制
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
```

# futures::lock

当使用多线程 `Future` 执行器( `executor` )时， `Future` 可能会在线程间被移动，因此 `async` 语句块中的变量必须要能在线程间传递。 至于 `Future` 会在线程间移动的原因是：它内部的任何`.await`都可能导致它被切换到一个新线程上去执行。

由于需要在多线程环境使用，意味着 `Rc`、 `RefCell` 、没有实现 `Send` 的所有权类型、没有实现 `Sync` 的引用类型，它们都是不安全的，因此无法被使用

类似的原因，在 `.await` 时使用普通的锁也不安全，例如 `Mutex` 。原因是，它可能会导致线程池被锁：当一个任务获取锁 `A` 后，若它将线程的控制权还给执行器，然后执行器又调度运行另一个任务，该任务也去尝试获取了锁 `A` ，结果当前线程会直接卡死，最终陷入死锁中。

因此，为了避免这种情况的发生，**需要使用 `futures` 包下的锁 `futures::lock` 来替代 `Mutex` 完成任务**。

