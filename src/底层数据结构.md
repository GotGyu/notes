## 堆，栈

### 栈

- 栈内存从**高位地址向下增长**，且栈内存是**连续分配**的
- Rust 中，`main` 线程的栈大小是 `8MB`，普通线程是 `2MB`
- 函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 `Drop` 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是**非常高效**的
- 栈更高效是因为操作系统会在底层对栈提供支持，分配专门的寄存器存放站的地址
- 栈上数据转移所有权时，实际是把数据拷贝了一份，**所有权未转移**，变量有两份
- 栈中的所有数据都必须**占用已知且固定大小**的内存空间

### 堆

- 堆内存从**低位地址向上增长**，**堆内存通常只受物理内存限制**，而且通常是**不连续**的
- 获取堆的内容需要两次访问，第一次访问指针，第二次根据指针访问内存
- 堆上数据转移所有权时，是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效
- 对于**大小未知或者可能变化的数据**，我们需要将它存储在堆上

### 性能

- **在栈上分配内存比在堆上分配内存要快**，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。在堆上分配内存则需要更多的工作，因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。
- 但仍需要分情况讨论：
  - 小型数据，在栈上的分配性能和读取性能都要比堆上高
  - 中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址
  - 大型数据，只建议在堆上分配和使用

## Box

将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据，背后是调用 `jemalloc` 来做内存管理，所以堆上的空间无需我们手动管理

### 简单定义自己的 `Box<T>`

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

// 为MyBox实现Deref
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

## Drop

`Drop` trait 中的 `drop` 方法借用了目标的可变引用，而不是拿走所有权。 

## String

`String` 是一种智能指针，实现了 `Deref` 特征，在需要时会自动被转换为 `&str` 类型

## Vec

`Vec` 是一种智能指针，以 `Vec<i32>` 为例，内存布局如下：

![image-20250227101550395](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250227101550395.png)

即栈中存储一个智能指针，指向堆上的数组数据。