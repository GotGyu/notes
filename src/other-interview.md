网络上公开的Rust面经整理

# Rust

1. `Copy` 和 `Clone` 的区别
2. `Rc` 的作用
3. 内部可变性是什么？需要使用标准库哪个结构体？
4. `Mutex<T>` 和 `RwLock<T>` 
   - 对 T 的要求有什么区别？
   - `RwLock` 在哪里比较好：并发读很多的情况
   - `Mutex` 在哪里比较好
5. `Sized` 的含义
6. 什么时候会用到 `PhantomData`？
7. `{struct A;std::mem::size_of::<A>()}`的值是多少？
8. `Pin<T>`的作用是？
   - 防止内存移动，在接口上体现为不让用户拿到 `&mut T`
9. 为什么需要`Pin`？
10. 如何创建一个自引用结构体？
11. `<T: 'static>`意味着`T`是全局变量/常量吗？
12. 一般有哪些操作是需要unsafe来达成的？
13. unsafe意味着不安全吗？
14. 类型转换，i32是否可以传给`i64`形参，写一个泛型函数，同时支持`i64`和`i32`形参
15. 写个结构体，设置默认值并打印它
16. `derive` 派生能派生哪些属性
17. `async` 优雅关闭
18. fn Fn FnMut FnOnce 的区别
19. Rust 相比 C++ 的好处
    - 实现统一，不会出现不同平台不同行为的情况，不太容易碰到 UB
    - 包管理工具管理依赖很方便
    - 内存安全
    - 函数式风格，优雅、性能好
    - Rust的客观安全标准，使得报告和修复安全错误的沟通成本非常小。在 C/C++ 中，在错误报告中需要得到维护者的确认，以确定某些行为是bug还是预期行为，因为 API 滥用和 API 本身的错误之间没有明确的区别。相比之下，Rust 的安全规则提供了一个客观的标准来确定 bug 是谁的错
20. 用Rust获得安全的同时可能会影响效率，考虑效率优先还是安全优先？
21. 问Rust的时候问xx在C++里对应什么？如指针
22. 程序有哪些section，由什么组成？程序启动的过程？
23. 怎么判断数据分配在栈上还是分配在堆上?
24. Rust的常用trait
25. 锁有几种？说一下锁中毒
    - 持有锁的时候发生panic好像就是锁中毒
26. Trait Objct
27. 详细问了动态分发和静态分发及相关效率影响
28. 解释一下Rust中`Deref` 、`Drop`、`Clone`、`Copy`、`Any` 这几个`trait`
    - `Deref`是解引用语义，结合Rust中的自动解引用机制，可允许自定义包装类型如智能指针等变量像内部变量一样使用，但使用仅限于取`&self`，如果要取`&mut self`则需要`DerefMut`这个`trait`。
    - `Drop`即[析构函数](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=析构函数&zhida_source=entity)。在变量生命周期结束时将自动执行`drop`以销毁。
    - `Clone`是复制语义，可由用户实现，表示复制一个对象。任何可复制的类都可以实现这个`trait`。
    - `Copy`也是复制语义，但与`Clone`不同的是，它只是一个标记，用来告诉编译器，该类型可以直接通过`memcpy`复制，而无需其他动作。`Copy`通常用于原生类型及其组合类型（[结构体](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=结构体&zhida_source=entity)、元组、枚举等）。
    - `Any`提供了一种简单的动态[反射机制](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=反射机制&zhida_source=entity)，要求类型必须具有`'static`的生命周期。在运行时可以`downcast`到任意类型，但若实际类型与要转换的类型不一致时，将返回`Err`。
29. rust优势
    - 内存安全，并发安全，无gc
30. 对Rust函数式编程的理解？C时函数式编程吗？
31. Rust常用的设计模式
32. Rust使用迭代器的好处
    - 惰性
33. Rust的所有权、RAII、借用、生命周期
34. hashmap 和 concurrenthashmap

## 智能指针

1. 了解哪些智能指针？

   - `Box<T>`, `Rc<T>`, `Arc<T>`
   - `Box<T>` 是唯一所有权的指针，无额外开销
   - `Rc<T>` 是线程不安全的共享所有权的指针，由引用计数实现；配套`Weak<T>` 不具有所有权， 只用来跟踪该指针指向的资源是否已被销毁。
   - `Arc<T>`是线程安全的共享所有权的指针，其用法与`Rc<T>`基本相同。

2. 提到KDTree，父亲孩子相互引用，问 `Rc<T>` 和 `Weak<T>`

3. `Cell` 和 `RefCell`
   - 内部可变性

   - `Cell<T>`提供了一种内部可变的机制。可以通过`&self`修改内部的值，而无需通过`&mut self`。它是零开销的，但它的修改只能整体地修改，不能通过`&self`拿到内部的`&mut T`。

     另一种`RefCell<T>`则可以用`borrow`或`borrow_mut`通过`&self`拿到内部的 `&mut T`。但它是有运行时开销的，内部会记录当前的借用状态，是未被借用，还是被可变借用，还是被不可变借用，以及被不可变借用了多少次。

4. `BTreeMap` 的实现
   - B-Tree 是动态数目子节点，有分裂-合并操作的，对有 Cache 的现代 CPU 而言性能更好，比传统二叉树性能更好，因为它一次性拿比较多的数据出来可以填到一个 Cache Line 里

5. `RefCell` 大量使用时是正常现象吗？使用`RefCell` 有什么问题？

   - trait设计不合理，在需要 `&self`的方法上要改变内部状态。使用 `RefCell` 要遵循借用的使用规则，不然会导致运行时Panic

## 多线程

1. 用的哪个运行时，Tokio 还是 Async-std？
2. 讲一下 Async 的 Future
3. 讲一下 `Send` 和 `Sync`
   - 多线程的时候需要加上，编译器会自己推断一个结构是否 `Send`, 是否 `Sync`
4. Rust中的多线程thread编程和Async异步编程
5. 多线程好处很多,那Nginx为什么使用多进程而不是多线程?

## 宏

1. 过程宏

# 八股

## Linux操作

1. Git merge和Git rebase的区别及用法

## 操作系统

1. 协程和线程的区别？什么时候用协程、什么时候用线程？rust为什么没有协程？
   - 其实rust的异步库实现的就是类似协程的东西，协程本质就是task，而且在用户态。应该讲一下用户态和内核态的关系
2. 一个 process 下两个 thread，一个 thread 是否可以访问另一个 thread 栈上的内容？
   - 一个 process 下是一个单独的地址空间，如果拿到栈指针就行，拿不到就不可以
3. 虚拟内存、分页、页表的组织形式
4. 对于操作系统的整体理解
5. 发生系统调用时，内核发生了什么？
   - 存系统调用号到寄存器，执行中断，切换到内核态，将用户态的数据复制到内核态，在系统调用表找到系统调用进行处理，然后返回到用户态。（不一定对）
6. 一个 TCP server 的进程崩溃后，客户端会怎么反应吗？
   - Linux 内核在进程崩溃前，会向它连接的客户端发送 FIN 报文

## 计组

1. 虚拟地址到物理地址怎么映射的?
2. 32位的系统能访问4gb以上的内存吗？
   - 我答的不能 面试官说可以去查一下最新的Linux 【intel新的x86硬件PAE支持36寻址空间，但是多出来的部分是虚拟的地址空间，单个应用程序估计无法使用到超过4GB的空间(32为系统的最大int是4GB)，只能是多个进程合起来能够使用到4G以外的内存】
3. IO方面的select/epoll
4. 有没有看过汇编代码
5. 知道的栈寄存器的名字

## 计网

1. 进程间通信的方式
2. TCP慢启动过程
3. TCP/IP三次握手
4. 重传机制(超时重传 快重传)
5. TCP拥塞控制算法、流量控制
6. 浏览器访问url的过程，从osi七层模型往下讲
7. HTTP头、几种请求方式、HTTPS原理、认证过程、HTTP 2.0、QUIC、50x错误意义
8. HTTP/1.1 的 Pipelining 和HTTP/2的多路复用的区别
9. TLS握手过程

## 数据库

1. 一个名为order的数据库，有date 和name字段，要查 date 、name以及name=?&&?<date<? 怎么建索引？ 
   - 我讲了联合索引，其实自己不懂联合索引，所以后面追问的答不出了。。。好像问了最左匹配
2. 索引、B+索引和Hash索引的优缺点
3. 重点问Hash索引实际处理方法
4. 事务
5. 表级锁和行级锁
6. sql优化
7. 区间查找

# 机试

要考虑复杂度

1. 背包

   直接把输入省了，硬编码了输入去写

   用了 `[Option<i32>; MAX_NUMBER]` 来保存背包，然后用了一些 Rust 的语法特性比如 `Option::map_or` 之类的，反正是写对了

2. n个不同长度有序数组合并为1个有序数组 问思路

   **[Merge k sorted lists](https://leetcode.com/problems/merge-k-sorted-lists/)**

   一开始想的暴力法，后面在提示下联想到归并排序 O(nlogn），算法实现 写了大概二十多分钟

3. 接雨水（没跑出来）

4. 输入一个数列，代表一个地区的高低起伏海拔，计算在潮水退去之后，这个数列代表的“坑洼地”能存放多少水

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-1.png)

5. 两个从右往左的链表实现左对齐的加法

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-2.png)

   6. 写一个函数，接收两个矩形然后输出是否相交，矩形的数据结构自己设计
   7. 俩人轮流丢硬币，谁先扔到正面谁羸。A 先扔，然后问他俩的胜率各是多少
   8. 链表右对齐相加（lc445）
   9. 用栈进行括号匹配
   10. 实现一个 `Future` 的伪代码
   11. （社招）TCP的流处理：
   12. 要求：用户按user_id（ 3-byte ）、payload_len（ 3-byte ）和payload（长度根据前面的定）的格式来发送数据。每个 TCP 连接会源源不断地接收这类格式的消息。
       后面又追加了新的要求：要求限流，每分钟只允许同一个user_id的最多 10 个请求，不同连接都要共享。超过就拒绝。
       之前没有太多网络编程相关的经验，只能凭感觉写了。理清了需求，临时查了 tokio 的文档，就吭哧吭哧就开始写了。面试形式是一边写一边讨论，整个过程花了快 1.5 小时。代码写得很糙，不过需求基本实现了。
   
       最后问，如果服务器长时间运行，那限流使用的类型（我才知道我写的限流算法中的「滑动日志算法」，用一个HashMap维护）中的很多user记录得不到释放，内存会越占用越多。我回答是，用一个定时任务来清空过期的记录。但删除时需要加锁，会阻塞正常的流处理。暂时没有想到好的方法
   
   13. 实现滑动窗口时间限流算法

# 时事

1. 对下一代互联网的理解
2. 最近学到的新东西/新技术

# 项目

