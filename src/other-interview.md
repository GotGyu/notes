网络上能找到的的Rust面经整理

# Rust

## 概念

### 代码方面的概念

1. **深拷贝与浅拷贝**
   - 深拷贝（克隆）
     - 任何**自动**的复制都不是深拷贝
     - 深度复制**堆**上的数据，而不仅仅是栈上的数据
     - 使用 `clone` 是深拷贝
     - 性能较差
   - 浅拷贝
     - 只发生在**栈**上
     - 性能很高
     - `Copy` trait 实现的是浅拷贝
2. **内部可变性是什么？需要使用标准库哪个结构体？**
   - 内部可变性：即使某个值是不可变的，你仍然可以在该值内部修改它的内容
   - 需要用：
     - `Rc<T>` 和 `RefCell<T>` 结合：用于**单线程**中的内部可变性，`Rc<T>` 可以实现一个数据拥有多个所有者，`RefCell<T>` 可以实现数据的可变性
     - `Arc<T>` 和 `Mutex<T>` 结合：用于**多线程**中的内部可变性
3. **`{struct A;std::mem::size_of::<A>()}`的值是多少？**
   - `std::mem::size_of::<A>` 返回的是类型 `A` 在内存中占用的字节数
   - 对于一个没有任何字段的结构体，会分配至少 1 字节的内存空间，**以便可以正确地实例化它并放置在栈上**
4. **`<T: 'static>`意味着`T`是全局变量/常量吗？**
   - 不是，它的含义仅仅是 `T` 的生命周期是 `'static'`，即生命周期足够长，可以持续到程序的整个运行期间
5. **一般有哪些操作是需要 `unsafe` 来完成的？**
   - 解引用裸指针
   - 调用unsafe函数或方法
   - 实现unsafe特征
   - 访问或修改可变静态变量
   - 访问union的字段
6. **`derive` 派生能派生哪些属性**
   - Copy：复制
   - Clone：复制
   - Debug：打印
   - PartialEq：可以进行结构体的部分相等性比较
   - Eq：完全相等性比较
   - PartialOrd：可以对结构体进行部分有序性比较
   - Ord：完全有序性比较
7. **`fn`, `Fn`, `FnMut`, `FnOnce` 的区别**

   - `fn` 是定义函数的关键字，而另外三个是用于表示闭包类型的 trait
   - `Fn` 是最基本的闭包 trait，它表示闭包可以捕获其环境变量的**不可变引用**
   - `FnMut` 表示闭包可以捕获其环境变量的**可变引用**
   - `FnOnce` 表示闭包只能调用一次，即闭包可以**捕获其环境变量的所有权**
   - 所有的闭包都自动实现了 `FnOnce` trait，因此任何一个闭包都至少可以被调用一次
   - 没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
   - 不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

### 语言理解方面

1. **`unsafe` 意味着不安全吗？**
   - 不是，虽然是 `unsafe` 区域，但 Rust 仍然提供了强大的安全支撑，`unsafe` 并不能绕过 Rust 的借用检查，也不能关闭任何 Rust 的安全检查规则，例如在 `unsafe` 中使用**引用**时，该有的检查一样都不会少
   - 仅仅是在使用上题的 5 种能力时，编译器才不会进行内存安全方面的检查
   - `unsafe` 的存在主要是因为 Rust 的静态检查强大且保守，导致当编译器在分析代码时，一些正确代码会因为编译器无法分析出它的所有正确性，结果将这段代码拒绝，导致编译错误
   - 用了 `unsafe` 后需要人工替代编译器的部分职责来对其正确性和安全性负责任
   - 系统编程必须要操作内存，`unsafe` 的存在是有其必要性的

2. **Rust 相比 C++ 的好处**

   - 跨平台一致性
     - Rust 的行为在不同平台上是一致的，且 `rustc` 严格遵循语言规范，大大减少了 UB
     - C++可能会因为编译器差异出现不一致，而且UB常见且难以调试
   - 强大的包管理工具
     - 内置 `Cargo`，可以轻松管理项目依赖、构建、测试
     - 与 C++ 的依赖管理（如手动或使用 `Cmake`等工具）相比，更见简单、方便
   - 内存安全
     - Rust 通过所有权、借用、生命周期等机制，在编译时保证了内存安全
     - C++依赖于程序员手动管理内存，容易出现内存泄漏、悬空指针等问题
   - 函数式编程风格
     - Rust 支持函数式编程范式，提供了闭包、迭代器、模式匹配等特性，使代码更加简洁、优雅，提高代码可读性，且在不牺牲性能的情况下实现高效抽象
   - 客观的安全标准
     - Rust 的安全规则提供了一个客观的标准，可以明确区分 API 滥用和 API 本身的错误，编译器会明确指出问题的根源
     - 在 C/C++ 中，错误报告往往需要维护者确认某些行为是bug还是预期行为，沟通成本较高
   - 零成本抽象
     - Rust 的设计哲学之一是“零成本抽象”，即高级抽象（如迭代器、泛型）在运行时不会引入额外的性能开销
     - 与 C++ 的模板元编程相比，Rust 的泛型和 trait 系统更加直观和安全，同时保持了高性能
   - 更好的错误处理
     - Rust 提供了 `Result` 和 `Option` 类型，强制程序员显式处理可能的错误和空值
     - 避免了 C++ 中常见的未处理异常或空指针问题
   - 文档和测试一体化
     - Rust 的文档注释（`///`）和测试代码可以无缝集成到项目中
     - C++ 需要自己编写测试代码

3. **用Rust获得安全的同时可能会影响效率，考虑效率优先还是安全优先？**

   - Rust 的设计哲学是**零成本抽象**，即在保证安全性的同时，尽量不引入额外的运行时开销。然而，在某些情况下，为了追求更高的效率，可能需要放松一些安全约束
   - 在对性能要求比较高的场景中，可能需要优先考虑效率，如使用 `unsafe` 代码、使用内联汇编（`asm!` 宏）直接编写底层指令
   - 在大多数情况下，安全性仍是首要考虑的因素，尤其是它用来开发一些关键基础设施，如OS、区块链、金融系统等，安全性至关重要，而且项目长期维护，也可以减少潜在的bug

4. **Rust的各种特性（指针、数据结构等）在C++里对应什么？**

   | 特性             | C++                                            | Rust                                |
   | :--------------- | :--------------------------------------------- | :---------------------------------- |
   | **指针与引用**   | 原始指针 `int* ptr = &x`                       | 引用 `&T``&mut T`                   |
   |                  | 独占所有权的智能指针  `std::unique_ptr<T>`     | 独占所有权的智能指针`Box<T>`        |
   |                  | 共享所有权的智能指针 `std::shared_ptr<T>`      | 引用计数的智能指针`Rc<T>` `Arc<T>`  |
   |                  | 不增加引用计数的弱引用 `std::weak_ptr<T>`      | 弱引用 `Weak<T>`                    |
   | **数据结构**     | 动态数组`std::vector<T>`                       | 动态数组 `Vec<T>`                   |
   |                  | 基于红黑树的有序映射 `std::map<K, V>`          | 基于B树的有序映射 `BTreeMap<K,V>`   |
   |                  | 基于哈希表的无序映射 `std::unordered_map<K,V>` | 基于哈希表的无序映射 `HashMap<K,V>` |
   |                  | 基于红黑树的有序集合 `std::set<T>`             | 基于B树的有序集合 `BTreeSet<T>`     |
   |                  | 基于哈希表的无序集合 `std::unordered_set<T>`   | 基于哈希表的无序集合 `HashSet<T>`   |
   | **并发与多线程** | `std::thread`、`std::mutex`                    | `std::thread`、`Mutex`              |
   | **面向对象编程** | 抽象类                                         | `trait` 定义接口                    |
   |                  | 多态                                           | `dyn trait` 动态分发                |
   | **泛型与模板**   | `template<typename T>` 定义泛型函数或类        | `fn foo<T>(x: T)` 定义泛型函数      |

   

5. **Rust 程序有哪些 section，由什么组成？程序启动的过程？**

   - 程序在编译后会生成一个二进制文件，该文件包含多个 **section**（段），是程序在内存中的逻辑分区，包括：
     - 代码段 `.txt`
       - 包含程序的机器指令（即编译后的代码）
     - 数据段
       - `.data`：**已初始化**的全局变量和静态变量
       - `.bss`：**未初始化**的全局变量和静态变量
       - `.rodata`：只读数据（如字符串常量）
     - 堆 （Heap）
       - 动态分配的内存区域，用于存储运行时分配的数据（如 `Box`、`Vec` 等）
     - 栈 （Stack）
       - 用于存储函数调用的局部变量、参数和返回地址
       - 栈是 LIFO（后进先出）结构，由编译器自动管理
     - 元数据段
       - **Rust 特有的 section**，包含程序的元信息，如 panic 处理函数、堆栈展开信息等
   - 一个典型的 Rust 程序由以下部分组成：
     - 入口函数 `main`
     - 依赖库 `crate`，通过 `Cargo.toml` 文件管理
     - 模块 `mod`，可以通过 `mod` 组织代码，可以嵌套
     - 全局变量，需要通过 `lazy_static` 或 `OnceCell` 等机制实现延迟初始化
   - 程序启动过程可以分为以下几个阶段：
     - 加载程序
       - 操作系统将程序的二进制文件加载到内存中
       - 解析程序的 section（如 `.text`、`.data`、`.bss` 等）
     - 初始化运行时
       - 设置堆栈、初始化全局变量等
       - Rust 的运行时（runtime）非常轻量，主要负责堆栈展开（unwinding）和 panic 处理
     - 调用 `main` 函数
       - `main` 是代码实际入口
     - 执行用户代码
       - 按逻辑执行
     - 程序结束
       - `main` 返回时，程序结束
       - 释放所有资源（如堆内存、文件句柄等）

6. 

## 数据结构

1. **关于 `Pin<T>`**

   - **作用是什么？**
     - 一个包装类型，防止某个数据的内存位置移动
     - 在接口上体现为不让用户拿到 `&mut T`，确保指向数据的指针不能随意改变
   - **为什么需要它？**
     - 通常用于与异步编程和 `Future` 相关的场景
     - 因为异步任务会在运行时暂停和恢复，如果数据在这种暂停恢复过程中被移动了，可能会导致不可预期的行为

2. **如何创建一个自引用结构体？**

   - Rust 中的一个关键约束是**结构体中的字段不能直接引用结构体中的其他字段**，因为它们的生命周期通常是相互依赖的，这会导致生命周期不一致的问题

   - 为了实现，需要借助 `Pin, UnsafeCell, RefCell` 等

     ```rust
     use std::cell::RefCell;
     use std::pin::Pin;
     
     struct SelfRef<'a> {
         data: String,
         data_ref: RefCell<Option<&'a str>>, // 通过 RefCell 包装引用，使其可以在运行时修改
     }
     
     impl<'a> SelfRef<'a> {
         // 构造函数，初始化 `SelfRef` 实例
         // 为了确保函数返回时数据的所有权不会被转移，将它放在堆上，唯一的访问方式就是通过指针
         fn new(data: String) -> Pin<Box<SelfRef<'a>>> {
             let mut self_ref = Box::pin(SelfRef {
                 data: data,
                 data_ref: RefCell::new(None), // 初始化引用为 None
             });
     
             // 设置数据引用为 `data` 的字符串切片
             let data_ref = &self_ref.data;
             *self_ref.data_ref.borrow_mut() = Some(data_ref);
     
             self_ref
         }
     
         // 获取引用，返回一个 `Option<&str>`，此时是借用数据
         fn get_data_ref(&self) -> Option<&str> {
             self.data_ref.borrow().clone()
         }
     }
     
     fn main() {
         let data = String::from("Hello, World!");
         let self_ref = SelfRef::new(data);
     
         // 访问自引用字段
         if let Some(data_ref) = self_ref.get_data_ref() {
             println!("{}", data_ref);
         }
     }
     ```

     

## 特征

1. **`Copy` 和 `Clone` 的区别？**

   - 共同点：两者都是用于进行值的复制的trait，`Copy` 是 `Clone` 的一个特例——所有实现了 `Copy` 的类型也会实现 `Clone`，但是反之则不成立。
   - 不同点：

   | 特征       | `Copy`                                                       | `Clone`                                                      |
   | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 语义       | 简单的按位复制                                               | 深拷贝，通常会**在堆上分配新的内存并复制数据**               |
   | 适用类型   | 基本类型，如整数、浮点数、布尔值等，通常**不涉及堆内存**     | 需要进行深度复制的类型，如 `String`、`Vec<T>`                |
   | 自动化程度 | **自动复制**，无需显式调用方法                               | 需要**显式调用** `.clone()` 方法                             |
   | 性能       | **高效**，**不涉及资源管理**（没有复杂、额外的内存分配、资源释放操作） | **相对较慢**，可能涉及堆内存分配和复制                       |
   | 例子       | `i32`, `f64`, `char`, `[i32; 3]` 等，当一个类型实现了 `Copy` 特征时，可以直接对它进行赋值，或者通过传递参数时“复制”值，而不需要显式调用 `clone` 方法 | `String`, `Vec<T>`, `Box<T>`, `Rc<T>` 等，通过 `Clone`，类型的实例会创建一个新的副本 |

   

2. **`Sized` 的含义**

   - 用于表示一个类型的大小在编译时已知且固定，即所有在编译时能计算出确切的内存大小的类型，才会实现 `Sized` trait
   - 所有在 Rust 中的类型默认都会实现 `Sized`，除非显式地标记为不实现 `Sized`（例如，某些类型如切片、动态大小类型DST等）
   - 通常不需要手动实现 `Sized`
   - 没有实现 `Sized` trait 的类型无法直接作为普通的值使用，必须通过引用 `&`来处理
   - `?Sized` 表示一个泛型类型可以是**动态大小类型**

3. **什么时候会用到 `PhantomData`？**

   - **所有权标记**：当希望一个类型“拥有”某个泛型参数，但实际上并不存储该类型的值时
   - **生命周期标记**：当需要表达一个类型与某个生命周期相关，但实际数据并不直接包含该生命周期时
   - **未使用的类型参数**：泛型类型中，如果某些类型参数未被直接使用，编译器可能会报错，用了这个类型就不会报错

4. 

5. - 
   
7. 

12. 

13. 

9. - 

17. 

18. 

20. 怎么判断数据分配在栈上还是分配在堆上?

21. Rust的常用trait

22. 锁有几种？说一下锁中毒
    - 持有锁的时候发生panic好像就是锁中毒

23. Trait Objct

24. 详细问了动态分发和静态分发及相关效率影响

25. 解释一下Rust中`Deref` 、`Drop`、`Clone`、`Copy`、`Any` 这几个`trait`
    - `Deref`是解引用语义，结合Rust中的自动解引用机制，可允许自定义包装类型如智能指针等变量像内部变量一样使用，但使用仅限于取`&self`，如果要取`&mut self`则需要`DerefMut`这个`trait`。
    - `Drop`即[析构函数](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=析构函数&zhida_source=entity)。在变量生命周期结束时将自动执行`drop`以销毁。
    - `Clone`是复制语义，可由用户实现，表示复制一个对象。任何可复制的类都可以实现这个`trait`。
    - `Copy`也是复制语义，但与`Clone`不同的是，它只是一个标记，用来告诉编译器，该类型可以直接通过`memcpy`复制，而无需其他动作。`Copy`通常用于原生类型及其组合类型（[结构体](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=结构体&zhida_source=entity)、元组、枚举等）。
    - `Any`提供了一种简单的动态[反射机制](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=反射机制&zhida_source=entity)，要求类型必须具有`'static`的生命周期。在运行时可以`downcast`到任意类型，但若实际类型与要转换的类型不一致时，将返回`Err`。

26. rust优势
    - 内存安全，并发安全，无gc

27. 对Rust函数式编程的理解？C时函数式编程吗？

28. Rust常用的设计模式

29. Rust使用迭代器的好处
    - 惰性

30. Rust的所有权、RAII、借用、生命周期

31. hashmap 和 concurrenthashmap

## 智能指针

1. 了解哪些智能指针？

   - `Box<T>`, `Rc<T>`, `Arc<T>`
   - `Box<T>` 是唯一所有权的指针，无额外开销
   - `Rc<T>` 是线程不安全的共享所有权的指针，由引用计数实现；配套`Weak<T>` 不具有所有权， 只用来跟踪该指针指向的资源是否已被销毁。
   - `Arc<T>`是线程安全的共享所有权的指针，其用法与`Rc<T>`基本相同。

2. `Rc` 的作用

3. 提到KDTree，父亲孩子相互引用，问 `Rc<T>` 和 `Weak<T>`

4. `Cell` 和 `RefCell`
   - 内部可变性

   - `Cell<T>`提供了一种内部可变的机制。可以通过`&self`修改内部的值，而无需通过`&mut self`。它是零开销的，但它的修改只能整体地修改，不能通过`&self`拿到内部的`&mut T`。

     另一种`RefCell<T>`则可以用`borrow`或`borrow_mut`通过`&self`拿到内部的 `&mut T`。但它是有运行时开销的，内部会记录当前的借用状态，是未被借用，还是被可变借用，还是被不可变借用，以及被不可变借用了多少次。

5. `BTreeMap` 的实现
   - B-Tree 是动态数目子节点，有分裂-合并操作的，对有 Cache 的现代 CPU 而言性能更好，比传统二叉树性能更好，因为它一次性拿比较多的数据出来可以填到一个 Cache Line 里

6. `RefCell` 大量使用时是正常现象吗？使用`RefCell` 有什么问题？

   - trait设计不合理，在需要 `&self`的方法上要改变内部状态。使用 `RefCell` 要遵循借用的使用规则，不然会导致运行时Panic

## 多线程

1. **`Mutex<T>` 和 `RwLock<T>`** 
   - **对 T 的要求有什么区别？**
     - `Mutex<T>` 要求 `T` 实现 `Send` 和 `Sync`
     - `Rwlock<T>` 要求 `T` 实现 `Send`，通常不要求 `Sync`
   - **`RwLock` 的使用场景？**
     -  最适合用在**并发读多于写的情况**。它允许多个线程同时持有**读锁**，从而实现多个线程可以同时读取数据而不会发生竞争。如果有线程需要写数据，它会**请求写锁并阻塞所有其他的读和写操作**
     - 理想使用场景：共享数据的并发读取、频繁读取，少量写入（如缓存、配置读取、状态监控等场景，读取远远超过写入）
   - **`Mutex` 的使用场景？**
     - 最适合用在**数据写操作比较频繁的情况**。`Mutex` 通过互斥锁确保同一时刻只有一个线程能够访问数据，适用于对数据进行单线程化访问的场景。
     - 理想使用场景：需要频繁修改数据，需要排他锁来保证数据一致性（比如状态更新、批量处理、缓存写入等场景）
2. 用的哪个运行时，Tokio 还是 Async-std？
3. Rust中的多线程thread编程和Async异步编程
4. 关于 `async`
   - 说一下 `async` 和 `Future`
   - 什么是`async` 的优雅关闭？
5. 
6. 讲一下 `Send` 和 `Sync`
   - 多线程的时候需要加上，编译器会自己推断一个结构是否 `Send`, 是否 `Sync`
7. 
8. 多线程好处很多,那Nginx为什么使用多进程而不是多线程?

## 宏

1. 过程宏

# 八股

## Linux操作

1. Git merge和Git rebase的区别及用法

## 操作系统

1. 协程和线程的区别？什么时候用协程、什么时候用线程？rust为什么没有协程？
   - 其实rust的异步库实现的就是类似协程的东西，协程本质就是task，而且在用户态。应该讲一下用户态和内核态的关系
2. 一个 process 下两个 thread，一个 thread 是否可以访问另一个 thread 栈上的内容？
   - 一个 process 下是一个单独的地址空间，如果拿到栈指针就行，拿不到就不可以
3. 虚拟内存、分页、页表的组织形式
4. 对于操作系统的整体理解
5. 发生系统调用时，内核发生了什么？
   - 存系统调用号到寄存器，执行中断，切换到内核态，将用户态的数据复制到内核态，在系统调用表找到系统调用进行处理，然后返回到用户态。（不一定对）
6. 一个 TCP server 的进程崩溃后，客户端会怎么反应吗？
   - Linux 内核在进程崩溃前，会向它连接的客户端发送 FIN 报文

## 计组

1. 虚拟地址到物理地址怎么映射的?
2. 32位的系统能访问4gb以上的内存吗？
   - 我答的不能 面试官说可以去查一下最新的Linux 【intel新的x86硬件PAE支持36寻址空间，但是多出来的部分是虚拟的地址空间，单个应用程序估计无法使用到超过4GB的空间(32为系统的最大int是4GB)，只能是多个进程合起来能够使用到4G以外的内存】
3. IO方面的select/epoll
4. 有没有看过汇编代码
5. 知道的栈寄存器的名字

## 计网

1. 进程间通信的方式
2. TCP慢启动过程
3. TCP/IP三次握手
4. 重传机制(超时重传 快重传)
5. TCP拥塞控制算法、流量控制
6. 浏览器访问url的过程，从osi七层模型往下讲
7. HTTP头、几种请求方式、HTTPS原理、认证过程、HTTP 2.0、QUIC、50x错误意义
8. HTTP/1.1 的 Pipelining 和HTTP/2的多路复用的区别
9. TLS握手过程

## 数据库

1. 一个名为order的数据库，有date 和name字段，要查 date 、name以及name=?&&?<date<? 怎么建索引？ 
   - 我讲了联合索引，其实自己不懂联合索引，所以后面追问的答不出了。。。好像问了最左匹配
2. 索引、B+索引和Hash索引的优缺点
3. 重点问Hash索引实际处理方法
4. 事务
5. 表级锁和行级锁
6. sql优化
7. 区间查找

# 机试

要考虑复杂度

## 简单题

1. **类型转换，`i32`是否可以传给`i64`形参？写一个泛型函数，同时支持`i64`和`i32`形参**

   - 是的，`i32` 可以转换为 `i64`，因为 `i64` 的范围更大，这是一种安全转换只要用 `as i64` （显式转换）或者 `.into()` （隐式转换）即可
   - `Into<i64>` 是一个 trait，表示可以将类型转换为 `i64`，约束泛型参数为 `Into<i64>`，可以同时支持 `i32` 和 `i64`

   ```rust
   fn function<T: Into<i64>>(value: T) {
       let value_i64: i64 = value.into();
       println!("{}", value_i64);
   }
   
   fn main() {
       let x: i32 = 1;
       let y: i64 = 1;
       function(x);
       function(y);
   }
   ```

2. **写一个结构体，设置默认值并打印它**

   ```rust
   #[derive(Debug)]
   struct A {
       key: i64,
       value: i64,
   }
   
   // 为 A 实现 Default trait
   impl Default for A {
       fn default() -> Self {
           A {
               key: 1,
               value: 2,
           }
       }
   }
   
   fn main() {
       let a = A::default();
       println!("{:?}", a);
   }
   ```

   

## LC题

1. 背包

   直接把输入省了，硬编码了输入去写

   用了 `[Option<i32>; MAX_NUMBER]` 来保存背包，然后用了一些 Rust 的语法特性比如 `Option::map_or` 之类的，反正是写对了

2. n个不同长度有序数组合并为1个有序数组 问思路

   **[Merge k sorted lists](https://leetcode.com/problems/merge-k-sorted-lists/)**

   一开始想的暴力法，后面在提示下联想到归并排序 O(nlogn），算法实现 写了大概二十多分钟

3. 接雨水（没跑出来）

4. 输入一个数列，代表一个地区的高低起伏海拔，计算在潮水退去之后，这个数列代表的“坑洼地”能存放多少水

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-1.png)

5. 两个从右往左的链表实现左对齐的加法

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-2.png)

   6. 写一个函数，接收两个矩形然后输出是否相交，矩形的数据结构自己设计
   7. 俩人轮流丢硬币，谁先扔到正面谁羸。A 先扔，然后问他俩的胜率各是多少
   8. 链表右对齐相加（lc445）
   9. 用栈进行括号匹配
   10. 实现一个 `Future` 的伪代码
   11. （社招）TCP的流处理：
   12. 要求：用户按user_id（ 3-byte ）、payload_len（ 3-byte ）和payload（长度根据前面的定）的格式来发送数据。每个 TCP 连接会源源不断地接收这类格式的消息。
       后面又追加了新的要求：要求限流，每分钟只允许同一个user_id的最多 10 个请求，不同连接都要共享。超过就拒绝。
       之前没有太多网络编程相关的经验，只能凭感觉写了。理清了需求，临时查了 tokio 的文档，就吭哧吭哧就开始写了。面试形式是一边写一边讨论，整个过程花了快 1.5 小时。代码写得很糙，不过需求基本实现了。
   
       最后问，如果服务器长时间运行，那限流使用的类型（我才知道我写的限流算法中的「滑动日志算法」，用一个HashMap维护）中的很多user记录得不到释放，内存会越占用越多。我回答是，用一个定时任务来清空过期的记录。但删除时需要加锁，会阻塞正常的流处理。暂时没有想到好的方法
   
   13. 实现滑动窗口时间限流算法

# 时事

1. 对下一代互联网的理解
2. 最近学到的新东西/新技术

# 项目

