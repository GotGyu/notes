# 操作系统

1. **进程间通信**
   - IPC 是指在不同进程之间传递数据或信号的机制
   - **管道**
     - 特点：
       - 半双工通信：数据只能单向流动。
       - 只能在具有亲缘关系的进程之间使用（如父子进程）。
       - 数据以字节流的形式传输。
     - 应用场景：
       - Linux命令（需查阅）
   - **命名管道**
     - 特点
       - 全双工通信：数据可以双向流动。
       - 可以在无关进程之间使用。
       - 通过文件系统中的命名管道文件进行通信。
     - 应用场景（需查阅）
   - **消息队列**
     - 特点
       - 通过消息队列传递结构化数据。
       - 消息可以按类型分类，支持优先级。
       - 消息队列独立于进程存在，进程终止后消息队列仍然存在。
   - **共享内存**
     - 特点
       - 多个进程共享同一块内存区域。
       - **通信速度最快**，但需要同步机制（如信号量）避免竞争。
       - 和mmap有什么区别（需查阅）
   - 信号量
     - 特点
       - 用于进程间的同步，控制对共享资源的访问。
       - 可以用于解决生产者-消费者问题。
   - 套接字socket
     - 特点
       - 支持网络通信，可以在不同主机上的进程之间通信。
       - 支持多种协议（如 TCP、UDP）
2. 进程、线程、协程的区别
3. 单线程+IO多路复用和多线程的区别
4. 操作系统进程切换过程
5. 用户态和内核态的区别？什么时候在用户态，什么时候在内核态，用户态什么时候切换到内核态，怎么返回用户态？
6. 多线程同步
7. Linux中时间片是按照进程去分的吗？
8. 说一下死锁以及如何避免死锁？
9. 关于虚拟内存，它是什么？为什么要用？优缺点？怎么实现的？
10. `cat` 读取文件，OS是怎么处理的？
11. 怎么检测到 `cat` 二进制文件，用什么命令执行？（exec）
12. 怎么找到文件在磁盘上的位置（只记得有个磁盘号，可以换算成3个参数，然后去磁盘上找）
13. 读写系统调用的过程
14. 还有哪些其他的系统调用
15. epoll怎么用到？epoll相对其他IO多路复用的优势？

# 计算机网络

**计算机网络模型（OSI模型）**

- 物理层：集线器、中继器、调制解调器
- 数据链路层：网桥、交换机
- 网络层：IP、ICMP、ARP、RARP、IPv6、NAT、路由器
- 传输层：TCP、UDP、网关
- 会话层
- 表示层
- 应用层：HTTP、HTTPS、FTP、SMTP、POP3、IMAP、DNS、SSH、SNMP、Telnet、

TCP/IP分层和每层的作用

## 网络层

1. **IP 协议概述**
   - 所有的TCP、UDP、ICMP数据都以IP数据报格式传输
   - IP在传输数据包时，将数据报文分为若干分片进行传输，并在目标系统中进行重组
   - 不同链路类型规定有不同最大长度的链路层数据帧，称为链路层MTU，常见的MTU=1500，若IP报文长度大于转发接口的MTU，则会将数据报文分为若干分片进行传输
   - 对于不同的传输层协议，在IP层上需不需要进行分片也是不同的：
     - **对于TCP，尽量避免分片。**因为当在IP层进行了分片后，如果其中的某片数据丢失，则需对整个数据报进行重传。避免分层的方法是，在3次握手时协商一个MSS值，用来表示本段所能接收的最大长度的报文段
     - **对于UDP而言可以分片。**
2. **IP分片可能出现的问题**

   - **性能消耗**：分片和重组会消耗发送方、接收方一定的CPU等资源，且分片对接收方内存资源的消耗较多
   - **丢包导致重传**：如果某个分片报文在网络传输过程中丢失，那么接收方将无法完成重组，如果应用进程要求重传的话，发送方必须重传所有分片报文而不是仅重传被丢弃的那个分片报文，这种效率低下的重传行为会给端系统和网络资源带来额外的消耗
   - **分片攻击**：黑客构造的分片报文，但是不向接收方发送最后一个分片报文，导致接收方要为所有的分片报文分配内存空间，可由于最后一个分片报文永远不会达到，接收方的内存得不到及时的释放（接收方会启动一个分片重组的定时器，在一定时间内如果无法完成重组，将向发送方发送ICMP重组超时差错报文，，只要这种攻击的分片报文发送的足够多、足够快，很容易占满接收方内存，让接收方无内存资源处理正常的业务，从而达到DOS的攻击效果
3. **NAT网络地址转换**
   - NAT路由器内部会维护一个NAT表，进行 `本地ip：端口`到 `外部网络ip：端口` 的映射

## 传输层

1. TCP报文的组成？

2. TCP的状态位有哪些？什么时候、具体什么事件会触发什么状态位？

3. **关于TCP协议和UDP协议**
   - 区别：
     - TCP：
       - 面向连接的、可靠的，确保数据包按顺序且无误地传送到接收方
       - 有流量控制、拥塞控制
     - UDP：
       - 无连接的、不可靠的，低延迟
       - 没有顺序保证或重传机制
       - 将数据分割成独立的数据报，带有一定信息，收到后再组装
       - 有简单的校验和机制
   - 应用场景：
     - TCP：适用于需要高可靠性和数据顺序保证的场景，如文件传输、电子邮件、远程登陆
     - UDP：适用于对传输速度要求较高、容忍一定数据丢失的场景，如视频流媒体、在线游戏、DNS查询
   - 在哪些协议中有用到：
     - TCP：[Telnet](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=Telnet&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJUZWxuZXQiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxNjkxMTIxNjksImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Gml07eGDbxa1jYaVJnEzfJtpRYWKdHsymc3SPDU94xM&zhida_source=entity)(远程登录)、[FTP](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=FTP&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJGVFAiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxNjkxMTIxNjksImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.iHZkXQxdmu2OQ4OgzxCbFIqo7lwdSoapeMxibvKo0Xo&zhida_source=entity)(文件传输协议)、[SMTP](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=SMTP&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJTTVRQIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTY5MTEyMTY5LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.il7Gezua-rDPO1Je3eM1wb_3lArMbaVGLPyPsi6jnEA&zhida_source=entity)(简单邮件传输协议)、HTTP、SSH
     - UDP：[NFS](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=NFS&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJORlMiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxNjkxMTIxNjksImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9._c_EheLfLeqLCL7fHxg7bxrYl7FuQnmFpdW2wwzJESw&zhida_source=entity)(网络文件系统)、[SNMP](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=SNMP&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJTTk1QIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTY5MTEyMTY5LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.rLg3eyWT43bqE6XZSqj5MXMOtt9Xq0Dm6O4pP7GmWcI&zhida_source=entity)(简单网络管理系统)、[DNS](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=DNS&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJETlMiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxNjkxMTIxNjksImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9._FLGpV3NGLy7sTSLlD0qopQtufLfCx0RL-sm0rsgjrE&zhida_source=entity)(主域名称系统)、[TFTP](https://zhida.zhihu.com/search?content_id=169112169&content_type=Article&match_order=1&q=TFTP&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDE5MzcwMDEsInEiOiJURlRQIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTY5MTEyMTY5LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.evs753NZcg7-JzU4J9zX8phKst5VHMRazegsuZKdJdY&zhida_source=entity)(通用文件传输协议)、NTP（网络时间协议）

4. **TCP三次握手详细描述，为什么要三次而不是两次**

   - 为了保证客户端和服务器端的可靠连接，TCP建立连接时**必须**要进行三次会话，也叫TCP三次握手，**目的是为了确认双方的接收能力和发送能力是否正常**
   - ![1741764800881](D:\WeChat\WeChat Files\wxid_4njvjhupxgbc22\FileStorage\Temp\1741764800881.png)
   - 最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器
   - TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN 监听状态
   - **第一次握手**TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态
   - **第二次握手**TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态
   - **第三次握手**TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手
   - **为什么要有第三次？**主要原因是，防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。举例而言：客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。

5. **TCP四次挥手详细描述**

   - 断开TCP连接需要四次挥手
   - ![1741765297104](D:\WeChat\WeChat Files\wxid_4njvjhupxgbc22\FileStorage\Temp\1741765297104.png)
   - 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭
   - **第一次挥手** 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态
   - **第二次挥手** 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态
   - **第三次挥手** 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认
   - **第四次挥手** 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成
   - **为什么客户端要等待2MSL？**主要原因是为了保证客户端发送的第一个ACK报文能到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文

## 应用层

1. **http和https**

   - HTTP
     - 用于在web浏览器和服务器之间传递信息的协议
     - 默认工作在TCP80端口
     - 以明文方式发送内容，不提供加密
     - 页面响应更快、资源消耗更低
   - HTTPS
     - 由HTTP进行通信，利用SSL/TLS加密数据包
     - 主要用于身份认证、保护交换数据的隐私与完整性
     - 默认工作在TCP443端口
     - 需要到CA申请证书
     - https如何解决不安全问题、加密方式有哪些？
   - **浏览器进行http请求的时候包含哪些头部**
     - 通用头部：适用于请求和响应，提供与消息本身相关的信息
     - 请求头部：用于传递客户端的详细信息、请求的上下文以及期望的响应格式
     - 实体头部：用于描述请求或响应的主体内容
     - GET请求包含1,2
     - POST请求包含1,2,3
     - PUT请求包含1,2,3
     - DELETE请求包含1,2

2. socket通信过程、客户端需要Bind吗

3. 讲讲为什么用select不用epoll？epoll比select好在哪？

   （答数据结构不同：红黑树加双向链表vs数组；答内核态用户态切换开销不一样）

4. websocket和socket的关系和区别？websocket是七层中的哪一层？（答应用层，不知道对不对），为什么不用socket而用websocket？

5. websocket和http的关系和区别？（答websocket能双向传输信息）又问http不能双向传输信息没？为什么你搭建的服务器不用http？

## 场景题

1. **在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤?**
   - 参考该链接：[经典面试题：在浏览器地址栏输入一个 URL 后回车，背后发生了什么-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1793846)

   - DNS解析域名 -> IP地址
     - 搜索**浏览器的DNS缓存**，其中维护着一张域名与IP地址的对应表
     - 若没有命中，则继续搜索**操作系统的DNS缓存**
     - 若没有命中，则操作系统将域名发送至**本地域名服务器**，它查询自己的DNS缓存，成功则返回结果，此处是递归查询
     - 若没有命中，则本地域名服务器向上级域名服务器进行迭代查询，得到IP地址后返回给操作系统，同时将其放在缓存里：
       - 本地域名服务器向**根域名服务器**发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案
       - 本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取**权限域名服务器**的地址
       - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
     - 操作系统将IP地址返回给浏览器，同时也将其放在缓存里
     - DNS使用UDP协议，以上所有请求转发过程都是基于UDP
   - 建立TCP连接，发送封装好的HTTP请求报文
     - 先通过三次握手为浏览器和服务器之间建立可靠的连接
     - TCP 会将 HTTP 报文按序号分割成若干报文段并加上 TCP 首部，分别进行传输。接收方在收到这些报文段后，按照序号以原来的顺序重组 HTTP 报文
   - IP封装数据报
     - TCP在各阶段操作时，都是通过IP协议进行传输的，IP将数据添加IP首部封装成IP数据包再进行传输
     - IP数据报首部存有**源IP地址、目标IP地址**
   - ARP查询目的MAC地址
     - ARP协议将IP地址转化为MAC地址，每个主机都有一个ARP高速缓存，里面有本局域网上各主机和路由器的**IP地址到MAC地址的映射表**
   - 物理层在硬件之间传输
   - 服务器响应请求
     - 浏览器的 HTTP 请求报文通过 TCP 三次握手建立的连接通道被切分成若干报文段分别发送给服务器，服务器在收到这些报文段后，按照序号以原来的顺序重组 HTTP 请求报文。然后处理并返回一个 HTTP 响应。当然，HTTP 响应报文也要经过和 HTTP 请求报文一样的过程
   - 断开TCP连接、浏览器显示界面

# C++

1. **三种智能指针**

   - `std::unique_ptr`

     - 特点
       - **独占所有权**：一个资源只能由一个 `std::unique_ptr` 拥有
       - **不可复制**：不能通过拷贝构造函数或赋值运算符复制 `std::unique_ptr`
       - **可移动**：可以通过 `std::move` 转移所有权
     - 使用场景：适用于需要独占资源所有权的场景，如动态分配的对象
     - 实现原理：

   - `std::shared_ptr`

     - 特点

       - **共享所有权**：多个 `std::shared_ptr` 可以共享同一个资源

       - **引用计数**：内部维护一个引用计数器，当引用计数为 0 时自动释放资源

       - **可复制**：可以通过拷贝构造函数或赋值运算符复制 `std::shared_ptr`

     - 使用场景：适用于需要共享资源所有权的场景，如多个对象共享同一个资源

     - 实现原理：

   - `std::weak_ptr`

     - **特点**
       - **弱引用**：不增加引用计数，不会影响资源的生命周期。
       - **解决循环引用**：用于打破 `std::shared_ptr` 的循环引用问题。
       - **需要转换为 `std::shared_ptr`**：通过 `lock()` 方法获取一个 `std::shared_ptr`
     - 使用场景：适用于需要观察资源但不拥有资源的场景，如缓存、观察者模式、

2. 智能指针的线程安全聊一下？

3. **`unique_ptr` 怎么赋值给另一个 `unique_ptr`？**

   - 只能通过**移动语义**将所有权转移来赋值

     ```c++
     std::unique_ptr<int> ptr1(new int(42));
     std::cout << "ptr1: " << *ptr1 << std::endl; // 输出 42
     
     // 将 ptr1 的所有权转移给 ptr2
     std::unique_ptr<int> ptr2 = std::move(ptr1);
     
     // ptr1 现在为空
     if (!ptr1) {
         std::cout << "ptr1 is now null" << std::endl;
     }
     
     // ptr2 现在拥有资源
     std::cout << "ptr2: " << *ptr2 << std::endl; // 输出 42
     ```

4. **`move` 的应用场景？**

   - 用于将对象的所有权从一个实例转移到另一个实例。它主要用于实现 **移动语义**，避免不必要的拷贝操作，从而提高性能

   - 应用场景：

     - 转移 `shard_ptr` 的所有权

     - 优化容器操作，避免拷贝构造，直接移动元素

       ```c++
       int main() {
           std::vector<std::string> vec;
           std::string str = "Hello";
       
           // 使用 std::move 将字符串移动到容器中
           vec.push_back(std::move(str));
       
           std::cout << "str after move: " << str << std::endl; // 输出空字符串
           std::cout << "vec[0]: " << vec[0] << std::endl; // 输出 Hello
       
           return 0;
       }
       ```

     - 实现移动构造函数和移动赋值运算符

     - 从函数返回局部对象

       ```c++
       std::string createString() {
           std::string str = "Hello, World!";
           return std::move(str); // 使用 std::move 返回
       }
       
       int main() {
           std::string result = createString();
           std::cout << result << std::endl; // 输出 Hello, World!
       
           return 0;
       }
       ```

     - 在需要传递或返回大型对象时，使用 `std::move` 避免深拷贝

   - **C++ 怎么保证线程安全**

     - 保证线程安全是确保多个线程并发访问共享资源时不会导致数据竞争或未定义行为的关键。标准库中的容器不是线程安全的
     - 
     - 使用互斥锁：线程同步，保护共享资源
     - 使用原子操作：简单的共享变量
     - 使用条件变量：用于线程间的通信，通常与互斥锁一起用
     - 使用无锁数据结构：通过原子操作实现线程安全，避免锁的开销

5. 右值&右值的作用？如果没有右值引用，怎么延长右值的生存期（常引用）

6. vector和list的区别？如果vector要加入的内容很多应该怎么做？push_back和emplace_back的区别？

7. 虚析构函数的必要性

8. C++内存泄漏如何判断

9. 内存数据存储位置

10. 模板类、模板函数

11. stl（vector/list...（应该按序列式和关联式分类说））

12. snprintf sprintf 

13. c++的多态底层怎么实现的（答虚函数，问底层，答虚指针）

14. `class A { void funv(){cout<<"hello"}}; A* a=nullptr;a->func()`有没有问题：

    没有。`func()` 在代码段静态编译，a没有实际对象只是没有this指针，dunc()里没有要用this访问成员变量，所以没问题

15. 析构函数virtual的意义？

16. new一个对象后调用free，有什么问题？

17. 为什么new和delete会导致资源消耗

18. new和malloc的区别

19. unordered_map和map的区别？为什么一般都用map？

20. 禁用掉的构造函数或运算符去使用会报什么错？在哪个时期？

21. 几种类型转换的方式有什么区别

22. crtp特性

23. 模板元编程？比如让templae T这个T只能接收某一个基类如何去实现？

24. const用在哪？（常量，常成员函数，底层const）

25. const &amp; 传参为什么效率高？（不需要拷贝）

26. vector超出容量会怎样？（以1.5或者2倍扩容）扩容基数？

27. 虚函数表是类还是对象拥有的？（类）

28. 怎么获取虚函数表？（虚表指针）

29. map查询效率?unordered_map是哈希表，O(1)；map是红黑树，O(logn)

30. map的key是自定义的类，需要注意什么?类要实现<的重载，保证key可以比较（也可以是函数对象）

31. 遇到过内存泄露吗？这里以为问的是项目（傻），说没有，使用了智能指针（应该举小例子）

32. 到过内存越界吗？这里答错了，讲成栈溢出（举例数组下标越界就行）

33. 编程遇到错误怎么解决？用过GDB吗？用vscode断点调试，没用过

34. 红黑树？怎么插入和删除？只讲了下概念，插入只记得要左旋或者右旋

35. 抽象类和接口的区别？

36. 内存泄漏是什么？举例子，如何排查内存泄漏？

# Linux 命令

1. Linux 怎么使用命令查看文件倒数三行

# 中间件/开源软件/框架

## Redis

### 基本概念

1. redis的持久化机制
2. redis的基本数据结构
3. redis的zset底层结构是什么
4. redis中hash结构的rehash过程是什么
5. lru和lfu的区别

### 集群

1. **集群相对于单机来说有什么不同点？**
   - 易于扩展，高性能，高可用性，但是需要额外维护成本
2. **集群如何进行数据同步？**
   - 主从同步，增量同步，全量同步，异步复制
   - 同步的时候有一个replication buffer缓冲区，会写入同步期间新增的数据，同步完rdb之后再同步这个命令，然后重放一次
3. **集群模式是否容易丢失数据？以及如何解决丢失数据的情况？**
   - 集群模式可能丢失数据，主要原因是异步复制
   - 解决方法：开启持久化（RDB/AOF），调整 `min-slaves-to-write` 和 `min-slaves-max-lag` 参数
4. **RDB 和 AOF 在使用的时候应该怎么选？**
   - RDB：适合数据备份，恢复速度快，对性能影响小，但可能丢失最后一次快照后的数据
   - AOF：数据安全性高，支持秒级持久化，但文件较大，恢复速度慢
   - 建议同时使用：RDB做冷备，AOF做热备，利用各自优势
5. **缓存穿透如果用空值法的话，如何避免大面积的内存被白白占用？**
   - 可以空值设置较短的TTL、使用布隆过滤器、后台任务定期检查和清理空值
6. **redisson相比于setnx灵活在哪？**
   -  同一线程可多次获取锁
   - 自动续期
   - 锁超时
   - 分布式支持
7. 采用延迟双删的情况下，如果MySQL数据库操作失败了怎么办？
8. **redis刷新token是如何保证用户无感？**

## nginx

1. nginx的七层和四层
1. 反向代理和正向代理的区别及对应的使用场景
1. 正向代理如何实现负载均衡

## gRPC

## webSocket

1. Stream 流的实现原理？

# 数据库

## 底层原理

1. 数据库采用的引擎？
2. MVCC 底层原理是什么？
3. **MySQL内部如何提高扫描效率？**
   - B+树索引，减少磁盘IO次数
   - 根据成本选择最优执行计划
   - InnoDB buffer pool缓存热数据
   - 提前读取可能需要的数据页
4. 为什么一般使用自增作为主键？（从数据库相关原理、索引方面回答）
5. 事务的隔离级别、索引？
6. 如何优化索引？
7. innodb 如何实现事务？
8. 还知道什么存储数据库引擎？

## 锁

1. 说说 MySQL 的锁机制
2. 乐观锁和悲观锁
3. **如何实现乐观锁？**为什么要用乐观锁？
   - 表中增加 `version` 字段，更新时检查版本
   - 条件更新 `UPDATE table SET data=?, version=version+1 WHERE id=? AND version=?`
4. 什么情况会出现超卖现象？乐观锁解决超卖如何实现？
5. 间隙锁是什么？用来处理什么情况？达到哪一种隔离级别

## SQL语句

1. 多表连接怎么优化
2. 多变连接的情况下，如果要分页查询该怎么改造？
3. 多表连接如何创建索引？联合索引是作用在哪里？
4. `join`, `from`, `groupby`, `order` 的执行顺序？

   - `FROM` > `JOIN` > `WHERE` > `GROUP BY` > `HAVING` > `SELECT` > `DISTINCT` > `ORDER BY` > `LIMIT`
5. 如何进行 SQL 语句优化？
6. 怎么判断加了索引？SQL 语句有没有用到索引？
7. 索引下推是什么？
8. 进行 `set` 语句的时候，undo log ,bin log ,redo log是怎么变化的？
9. MySQL 的 `join` 怎么优化

# 设计模式

## 后端

### 概念

1. **认证和鉴权的区别？**
   - 认证是确认用户是谁的过程，验证用户的身份
   - 鉴权是确认用户能有权限做什么的过程

### 场景

1. 如果后续你的项目需要进一步升级(如扩大范围、扩大研究数量)，你该使用什么办法来解决会遇到的问题？
1. 网络编程怎样实现多用户管理？
1. 如果要高缓存一致性又要并发应该怎么做？
1. 如何提升服务的可用性？
1. 如果有一个内存敏感性应用，从哪些方面做考虑？（池化，合理管理对象生命周期，避免内存泄漏，单例复用对象）
1. 如果现在一个10WQPS去生成订单号的服务接口，你怎么设计(我以为是下订单，一直说异步)，雪花算法，独立出服务加集群(忘了说etcd和zookeeper了)
1. 项目中日志怎么设计的？写日志的线程安全怎么考虑？锁的颗粒度较大怎么解决？了解过多级缓存吗（没有，扯了下原子锁）（日志分段（日志分为多个文件，按日期线程等维度划分，每个日志用一个锁、日志缓冲（暂存日志信息到缓冲区中，缓冲区满的时候线程处理日志，或者使用异步线程后台处理））

