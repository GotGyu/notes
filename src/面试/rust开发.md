网络上能找到的的Rust面经整理

# Rust

## 概念

### 代码方面的概念

1. **深拷贝与浅拷贝**
   - 深拷贝（克隆）
     - 任何**自动**的复制都不是深拷贝
     - 深度复制**堆**上的数据，而不仅仅是栈上的数据
     - 使用 `clone` 是深拷贝
     - 性能较差
   - 浅拷贝
     - 只发生在**栈**上
     - 性能很高
     - `Copy` trait 实现的是浅拷贝

2. **内部可变性是什么？需要使用标准库哪个结构体？**
   - 内部可变性：即使某个值是不可变的，你仍然可以在该值内部修改它的内容
   - 需要用：
     - `Rc<T>` 和 `RefCell<T>` 结合：用于**单线程**中的内部可变性，`Rc<T>` 可以实现一个数据拥有多个所有者，`RefCell<T>` 可以实现数据的可变性
     - `Arc<T>` 和 `Mutex<T>` 结合：用于**多线程**中的内部可变性

3. **`{struct A;std::mem::size_of::<A>()}`的值是多少？**
   - `std::mem::size_of::<A>` 返回的是类型 `A` 在内存中占用的字节数
   - 对于一个没有任何字段的结构体，会分配至少 1 字节的内存空间，**以便可以正确地实例化它并放置在栈上**

4. **`<T: 'static>`意味着`T`是全局变量/常量吗？**
   - 不是，它的含义仅仅是 `T` 的生命周期是 `'static'`，即生命周期足够长，可以持续到程序的整个运行期间

5. **一般有哪些操作是需要 `unsafe` 来完成的？**
   - 解引用裸指针
   - 调用unsafe函数或方法
   - 实现unsafe特征
   - 访问或修改可变静态变量
   - 访问union的字段

6. **如何禁止模块内使用 unsafe 代码？**

   ```rust
   #![forbid(unsafe_code)]
   // 或针对特定模块
   mod safe_module {
       #![deny(unsafe_code)]
       
       // 任何unsafe代码将触发编译错误
   }
   ```

   **应用场景**：

   - 安全关键代码库（如加密算法）
   - 团队协作时强制安全约束
   - 审计需求（如通过`cargo-geiger`检查）

7. **`derive` 派生能派生哪些属性**

   - Copy：复制
   - Clone：复制
   - Debug：打印
   - PartialEq：可以进行结构体的部分相等性比较
   - Eq：完全相等性比较
   - PartialOrd：可以对结构体进行部分有序性比较
   - Ord：完全有序性比较

8. **`fn`, `Fn`, `FnMut`, `FnOnce` 的区别**

   - `fn` 是定义函数的关键字，而另外三个是用于表示闭包类型的 trait
   - `Fn` 是最基本的闭包 trait，它表示闭包可以捕获其环境变量的**不可变引用**
   - `FnMut` 表示闭包可以捕获其环境变量的**可变引用**
   - `FnOnce` 表示闭包只能调用一次，即闭包可以**捕获其环境变量的所有权**
   - 所有的闭包都自动实现了 `FnOnce` trait，因此任何一个闭包都至少可以被调用一次
   - 没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
   - 不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

9. **调用 `.into_iter()` 而非 `.iter()` 的动机？**

   | 方法           | 所有权     | 适用场景         | 示例                     |
   | :------------- | :--------- | :--------------- | :----------------------- |
   | `.iter()`      | 借用       | 只读访问集合元素 | `for x in v.iter()`      |
   | `.into_iter()` | 转移所有权 | 需要消费集合     | `for x in v.into_iter()` |

10. **为何部分库强调支持 `no_std` 环境？**

    **应用场景**：

    - **嵌入式开发**：无操作系统环境（如ARM Cortex-M）
    - **内核开发**：操作系统内核等特权环境
    - **极致优化**：避免标准库开销（如WASM微服务）

    **限制与解决方案**：

    - 无堆分配 → 使用`alloc` crate+自定义全局分配器
    - 无线程 → 基于中断的并发模型
    - 无文件系统 → 实现`Read/Write` trait对接硬件

11. **为何不启用 Cargo 依赖的全部功能？Rust 的未用代码清除机制是否足够？**

    **禁用全特性的原因**：

    1. **编译时间**：未用特性仍可能导致额外编译
    2. **依赖冲突**：不同特性可能引入不兼容的依赖版本
    3. **条件控制**：通过`cfg`精细控制平台特定代码

    **Rust的未用代码清除**：

    - 虽然会消除未使用的函数（dead code elimination）
    - 但泛型实例化和宏展开仍可能引入冗余代码

12. 

13. 

14. 

15. 为何 std::mem::forget 不被标记为 unsafe？它如何绕过析构器？（资源泄漏的合法性、与 ManuallyDrop 的对比）

16. 

17. 为何 #[cfg(test)] 模块外的单元测试可能引发问题？如何正确组织测试代码？（编译条件隔离、集成测试与单元测试的边界）

18. 为何 unsafe 代码块中修改全局变量需使用 UnsafeCell 或原子操作？（未定义行为的触发条件、编译器优化的干扰）

### 语言理解方面

1. **`unsafe` 意味着不安全吗？**
   - 不是，虽然是 `unsafe` 区域，但 Rust 仍然提供了强大的安全支撑，`unsafe` 并不能绕过 Rust 的借用检查，也不能关闭任何 Rust 的安全检查规则，例如在 `unsafe` 中使用**引用**时，该有的检查一样都不会少
   - 仅仅是在使用上题的 5 种能力时，编译器才不会进行内存安全方面的检查
   - `unsafe` 的存在主要是因为 Rust 的静态检查强大且保守，导致当编译器在分析代码时，一些正确代码会因为编译器无法分析出它的所有正确性，结果将这段代码拒绝，导致编译错误
   - 用了 `unsafe` 后需要人工替代编译器的部分职责来对其正确性和安全性负责任
   - 系统编程必须要操作内存，`unsafe` 的存在是有其必要性的

2. **Rust 相比 C++ 的好处**

   - 跨平台一致性
     - Rust 的行为在不同平台上是一致的，且 `rustc` 严格遵循语言规范，大大减少了 UB
     - C++可能会因为编译器差异出现不一致，而且UB常见且难以调试
   - 强大的包管理工具
     - 内置 `Cargo`，可以轻松管理项目依赖、构建、测试
     - 与 C++ 的依赖管理（如手动或使用 `Cmake`等工具）相比，更见简单、方便
   - 内存安全
     - Rust 通过所有权、借用、生命周期等机制，在编译时保证了内存安全；微软研究表明，70%的C/C++安全漏洞源于内存错误，而Rust可从根本上避免此类问题
     - C++依赖于程序员手动管理内存，容易出现内存泄漏、悬空指针等问题
   - 函数式编程风格
     - Rust 支持函数式编程范式，提供了闭包、迭代器、模式匹配等特性，使代码更加简洁、优雅，提高代码可读性，且在不牺牲性能的情况下实现高效抽象
   - **无畏并发**
     - Rust 编译期静态检查并发代码的安全性，避免数据竞争，`Tokio` 异步运行时凭借此特性支撑高并发网络服务
   - 跨平台、底层控制、嵌入式优势
     - Rust 与 C/C++ 性能相当，开发者可直接操作内存，适用于游戏引擎、数据库等对性能要求苛刻的场景；支持从裸机（如STM32单片机）到 WASM 的全栈开发，还被 Linux 内核官方接纳为第二语言
   - 客观的安全标准
     - Rust 的安全规则提供了一个客观的标准，可以明确区分 API 滥用和 API 本身的错误，编译器会明确指出问题的根源
     - 在 C/C++ 中，错误报告往往需要维护者确认某些行为是bug还是预期行为，沟通成本较高
   - **零成本抽象**
     - Rust 的设计哲学之一是“零成本抽象”，即高级抽象（如迭代器、泛型、模式匹配）在运行时不会引入额外的性能开销，通过编译时严格的所有权和借用检查机制，彻底消除空指针、数据竞争等内存安全问题，无需依赖垃圾回收，使得在系统编程中表现卓越
     - 与 C++ 的模板元编程相比，Rust 的泛型和 trait 系统更加直观和安全，同时保持了高性能
   - 更好的错误处理
     - Rust 提供了 `Result` 和 `Option` 类型，强制程序员显式处理可能的错误和空值
     - 避免了 C++ 中常见的未处理异常或空指针问题
   - 文档和测试一体化
     - Rust 的文档注释（`///`）和测试代码可以无缝集成到项目中
     - C++ 需要自己编写测试代码

3. **用Rust获得安全的同时可能会影响效率，考虑效率优先还是安全优先？**

   - Rust 的设计哲学是**零成本抽象**，即在保证安全性的同时，尽量不引入额外的运行时开销。然而，在某些情况下，为了追求更高的效率，可能需要放松一些安全约束
   - 在对性能要求比较高的场景中，可能需要优先考虑效率，如使用 `unsafe` 代码、使用内联汇编（`asm!` 宏）直接编写底层指令
   - 在大多数情况下，安全性仍是首要考虑的因素，尤其是它用来开发一些关键基础设施，如OS、区块链、金融系统等，安全性至关重要，而且项目长期维护，也可以减少潜在的bug

4. **Rust的各种特性（指针、数据结构等）在C++里对应什么？**

   | 特性             | C++                                            | Rust                                |
   | :--------------- | :--------------------------------------------- | :---------------------------------- |
   | **指针与引用**   | 原始指针 `int* ptr = &x`                       | 引用 `&T``&mut T`                   |
   |                  | 独占所有权的智能指针  `std::unique_ptr<T>`     | 独占所有权的智能指针`Box<T>`        |
   |                  | 共享所有权的智能指针 `std::shared_ptr<T>`      | 引用计数的智能指针`Rc<T>` `Arc<T>`  |
   |                  | 不增加引用计数的弱引用 `std::weak_ptr<T>`      | 弱引用 `Weak<T>`                    |
   | **数据结构**     | 动态数组`std::vector<T>`                       | 动态数组 `Vec<T>`                   |
   |                  | 基于红黑树的有序映射 `std::map<K, V>`          | 基于B树的有序映射 `BTreeMap<K,V>`   |
   |                  | 基于哈希表的无序映射 `std::unordered_map<K,V>` | 基于哈希表的无序映射 `HashMap<K,V>` |
   |                  | 基于红黑树的有序集合 `std::set<T>`             | 基于B树的有序集合 `BTreeSet<T>`     |
   |                  | 基于哈希表的无序集合 `std::unordered_set<T>`   | 基于哈希表的无序集合 `HashSet<T>`   |
   | **并发与多线程** | `std::thread`、`std::mutex`                    | `std::thread`、`Mutex`              |
   | **面向对象编程** | 抽象类                                         | `trait` 定义接口                    |
   |                  | 多态                                           | `dyn trait` 动态分发                |
   | **泛型与模板**   | `template<typename T>` 定义泛型函数或类        | `fn foo<T>(x: T)` 定义泛型函数      |

   

5. **Rust 程序有哪些 section，由什么组成？程序启动的过程？**

   - 程序在编译后会生成一个二进制文件，该文件包含多个 **section**（段），是程序在内存中的逻辑分区，包括：
     - 代码段 `.txt`
       - 包含程序的机器指令（即编译后的代码）
     - 数据段
       - `.data`：**已初始化**的全局变量和静态变量
       - `.bss`：**未初始化**的全局变量和静态变量
       - `.rodata`：只读数据（如字符串常量）
     - 堆 （Heap）
       - 动态分配的内存区域，用于存储运行时分配的数据（如 `Box`、`Vec` 等）
     - 栈 （Stack）
       - 用于存储函数调用的局部变量、参数和返回地址
       - 栈是 LIFO（后进先出）结构，由编译器自动管理
     - 元数据段
       - **Rust 特有的 section**，包含程序的元信息，如 panic 处理函数、堆栈展开信息等
   - 一个典型的 Rust 程序由以下部分组成：
     - 入口函数 `main`
     - 依赖库 `crate`，通过 `Cargo.toml` 文件管理
     - 模块 `mod`，可以通过 `mod` 组织代码，可以嵌套
     - 全局变量，需要通过 `lazy_static` 或 `OnceCell` 等机制实现延迟初始化
   - 程序启动过程可以分为以下几个阶段：
     - 加载程序
       - 操作系统将程序的二进制文件加载到内存中
       - 解析程序的 section（如 `.text`、`.data`、`.bss` 等）
     - 初始化运行时
       - 设置堆栈、初始化全局变量等
       - Rust 的运行时（runtime）非常轻量，主要负责堆栈展开（unwinding）和 panic 处理
     - 调用 `main` 函数
       - `main` 是代码实际入口
     - 执行用户代码
       - 按逻辑执行
     - 程序结束
       - `main` 返回时，程序结束
       - 释放所有资源（如堆内存、文件句柄等）

6. **怎么判断数据分配在栈上还是分配在堆上?**

   - Rust 的内存管理模型非常清晰，所以分配在哪里取决于数据的类型和创建方式
   - 栈上分配的数据：
     - 基本数据类型：如 `i32`, `f64`, `bool`等
     - **固定大小**的复合类型：元组、数组、结构体等
     - 函数内部局部变量
   - 堆上分配的数据：
     - **动态大小**的类型：如 `String`, `Vec<T>`, `Box<T>` 等
     - 智能指针管理的数据：如 `Box<T>`, `Rc<T>`, `Arc<T>`等

7. 将多模块置于同一文件而非分拆的考量？（例如简化层级、小型模块管理）

8. 为何 Rust 不支持与其他 Rust 模块的共享/动态链接？（观察对方初步反应后解释）

## 数据结构

1. **关于 `Pin<T>`**

   - **作用是什么？**
     - 一个包装类型，防止某个数据的内存位置移动
     - 在接口上体现为不让用户拿到 `&mut T`，确保指向数据的指针不能随意改变
   - **为什么需要它？**
     - 通常用于与异步编程和 `Future` 相关的场景
     - 因为异步任务会在运行时暂停和恢复，如果数据在这种暂停恢复过程中被移动了，可能会导致不可预期的行为，具体来说：
     - `Future` 的方法签名是 `Pin<&mut self>`，而 `Future` 本质上是一个通过状态机实现的无状态 generator，即运行时并不会为每个 generator 维护上下文的状态，这些状态都是通过编译器变成 `Future` 里的数据，而 `Future` 有可能会被传递、移动，`Future` 里面的数据存在自引用的情况，那么 `Future` 被移动的话，这些自引用的指针就会变成野指针，从而导致异常

2. **如何创建一个自引用结构体？**

   - Rust 中的一个关键约束是**结构体中的字段不能直接引用结构体中的其他字段**，因为它们的生命周期通常是相互依赖的，这会导致生命周期不一致的问题

   - 为了实现，需要借助 `Pin, UnsafeCell, RefCell` 等

     ```rust
     use std::cell::RefCell;
     use std::pin::Pin;
     
     struct SelfRef<'a> {
         data: String,
         data_ref: RefCell<Option<&'a str>>, // 通过 RefCell 包装引用，使其可以在运行时修改
     }
     
     impl<'a> SelfRef<'a> {
         // 构造函数，初始化 `SelfRef` 实例
         // 为了确保函数返回时数据的所有权不会被转移，将它放在堆上，唯一的访问方式就是通过指针
         fn new(data: String) -> Pin<Box<SelfRef<'a>>> {
             let mut self_ref = Box::pin(SelfRef {
                 data: data,
                 data_ref: RefCell::new(None), // 初始化引用为 None
             });
     
             // 设置数据引用为 `data` 的字符串切片
             let data_ref = &self_ref.data;
             *self_ref.data_ref.borrow_mut() = Some(data_ref);
     
             self_ref
         }
     
         // 获取引用，返回一个 `Option<&str>`，此时是借用数据
         fn get_data_ref(&self) -> Option<&str> {
             self.data_ref.borrow().clone()
         }
     }
     
     fn main() {
         let data = String::from("Hello, World!");
         let self_ref = SelfRef::new(data);
     
         // 访问自引用字段
         if let Some(data_ref) = self_ref.get_data_ref() {
             println!("{}", data_ref);
         }
     }
     ```

3. **为何 `mem::replace` 或 `take` 方法在结构体更新中至关重要？**

   ```rust
   // 更新结构体字段时的所有权问题
   struct Processor {
       buffer: String,
   }
   
   impl Processor {
       fn update(&mut self, new_data: String) -> String {
           // 必须取出旧buffer，同时放入新buffer
           std::mem::replace(&mut self.buffer, new_data)
       }
   }
   ```

   **技术原理**：

   - **所有权转移**：通过`&mut`引用实现"偷取"数据
   - **避免无效状态**：保证`Option`取值的原子性操作
   - **性能优势**：比`clone+replace`更高效（仅指针交换）

   **`take` 的特殊价值**：

   ```rust
   let mut opt = Some(42);
   let taken = opt.take(); // opt变为None，taken为Some(42)
   ```

   专为`Option`设计，语义比 `replace(&mut opt, None)`更清晰

4. 为何选择使用 `str` 而非 `String`？

   - 轻量、不可变、栈分配 vs 堆分配

5. 为何优先使用 `Vec` 的 `pop`（顶部弹出）而非 `remove`（索引删除）？

   - 例如删除末尾元素更高效

6. 为何在公开模块中直接扩展 Vec 的自定义实现，而非封装隐藏内部 Vec 的结构体？（反之的优缺点？）

7. 若 BinaryHeap 性能弱于 BTreeSet（可能因场景而异），为何仍选择 BinaryHeap？（例如需优先级队列而非有序集合）

8. 为何标准库的 HashMap 默认使用 SipHash 而非更快哈希算法？何时需替换？（DDoS 防护与性能的取舍、BuildHasher 定制场景）

## 生命周期

1. **为何需显式定义接收两个引用并返回值的作用域函数模板，即使编译能通过？**

   ```rust
   // 显式标注版（推荐）
   fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
       if s1.len() > s2.len() { s1 } else { s2 }
   }
   
   // 隐式推断版（不推荐）
   fn longest(s1: &str, s2: &str) -> &str { /* ... */ }
   ```

   - **类型安全**：明确约束输入输出的生命周期关系
   - **可读性**：作为API契约的一部分，帮助调用者理解约束
   - **未来兼容**：避免编译器推断策略变化导致代码break

2. **如何利用生命周期为引用切片（涉及两个不同生命周期）定义迭代器？**

   ```rust
   struct SliceIter<'a, 'b: 'a, T> {
       first: &'a [T],
       second: &'b [T],
       index: usize,
   }
   
   impl<'a, 'b, T> Iterator for SliceIter<'a, 'b, T> {
       type Item = &'a T;  // 统一到更短的生命周期
   
       fn next(&mut self) -> Option<Self::Item> {
           if self.index < self.first.len() {
               let item = &self.first[self.index];
               self.index += 1;
               Some(item)
           } else {
               let adj_index = self.index - self.first.len();
               self.second.get(adj_index).map(|x| unsafe {
                   // 安全条件：'b outlives 'a
                   std::mem::transmute::<&'b T, &'a T>(x)
               })
           }
       }
   }
   ```

   **关键点**：

   1. `'b: 'a` 约束确保第二个切片生命周期覆盖第一个
   2. 使用`transmute`需要`unsafe`并确保安全条件

## 泛型

1. 为何倾向于使用 `AsRef<T>` 而非 `&[T]`？
2. 为何在泛型函数中优先实现 From<T> trait 而非直接接受 T 参数？（trait 约束的扩展性、错误处理的统一性）
3. 为何 impl Trait 在返回位置与参数位置的行为不同？何时选择泛型？（抽象语法糖的局限性、静态分发与动态分发选择）
4. 为何 Default trait 对泛型结构体的 #[derive(Default)] 有特殊要求？（自动派生条件、字段类型约束的传播）
5. 为何 serde 库的 deserialize 函数常返回 Result<T, E> 而非直接 T？（错误处理的必要性、部分解析与回滚机制）

## 特征

1. **`Copy` 和 `Clone` 的区别？**

   - 共同点：两者都是用于进行值的复制的trait，`Copy` 是 `Clone` 的一个特例——所有实现了 `Copy` 的类型也会实现 `Clone`，但是反之则不成立。
   - 不同点：

   | 特征       | `Copy`                                                       | `Clone`                                                      |
   | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 语义       | 简单的按位复制                                               | 深拷贝，通常会**在堆上分配新的内存并复制数据**               |
   | 适用类型   | 基本类型，如整数、浮点数、布尔值等，通常**不涉及堆内存**     | 需要进行深度复制的类型，如 `String`、`Vec<T>`                |
   | 自动化程度 | **自动复制**，无需显式调用方法                               | 需要**显式调用** `.clone()` 方法                             |
   | 性能       | **高效**，**不涉及资源管理**（没有复杂、额外的内存分配、资源释放操作） | **相对较慢**，可能涉及堆内存分配和复制                       |
   | 例子       | `i32`, `f64`, `char`, `[i32; 3]` 等，当一个类型实现了 `Copy` 特征时，可以直接对它进行赋值，或者通过传递参数时“复制”值，而不需要显式调用 `clone` 方法 | `String`, `Vec<T>`, `Box<T>`, `Rc<T>` 等，通过 `Clone`，类型的实例会创建一个新的副本 |

2. **`Sized` 的含义**

   - 用于表示一个类型的大小在编译时已知且固定，即所有在编译时能计算出确切的内存大小的类型，才会实现 `Sized` trait
   - 所有在 Rust 中的类型默认都会实现 `Sized`，除非显式地标记为不实现 `Sized`（例如，某些类型如切片、动态大小类型DST等）
   - 通常不需要手动实现 `Sized`
   - 没有实现 `Sized` trait 的类型无法直接作为普通的值使用，必须通过引用 `&`来处理
   - `?Sized` 表示一个泛型类型可以是**动态大小类型**

3. **什么时候会用到 `PhantomData`？**如何通过 PhantomData 标记未使用的生命周期或类型参数？需注意哪些陷阱？（零开销抽象、类型系统欺骗的合法性）

   - **所有权标记**：当希望一个类型“拥有”某个泛型参数，但实际上并不存储该类型的值时
   - **生命周期标记**：当需要表达一个类型与某个生命周期相关，但实际数据并不直接包含该生命周期时
   - **未使用的类型参数**：泛型类型中，如果某些类型参数未被直接使用，编译器可能会报错，用了这个类型就不会报错

4. **Rust 的常用 trait 有哪些？**

   | Trait 名称           | 用途                                                         | 如何使用                                                     |
   | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `Copy`               | 允许按位复制类型的值                                         | 添加 `#[derive(Copy)]`                                       |
   | `Clone`              | 允许显式复制类型的值                                         | 添加 `#[derive(Clone)]` 或手动实现 `clone` 方法              |
   | `Eq`                 | 表示类型可以进行相等性比较                                   | 添加 `#[derive(Eq)]` 或手动实现 `eq` 方法                    |
   | `PartialEq`          | 表示类型可以进行部分相等性比较                               | 添加 `#[derive(PartialEq)]` 或手动实现 `partial_eq` 方法     |
   | `Ord`                | 表示类型可以进行全序比较                                     | 添加 `#[derive(Ord)]` 或手动实现 `cmp` 方法                  |
   | `PartialOrd`         | 表示类型可以进行部分序比较                                   | 添加 `#[derive(PartialOrd)]` 或手动实现 `partial_cmp` 方法   |
   | `Debug`              | 允许格式化输出调试信息                                       | 添加 `#[derive(Debug)]` 或手动实现 `fmt` 方法                |
   | `Default`            | 允许为类型创建默认值                                         | 在类型定义上添加 `#[derive(Default)]` 或手动实现 `default` 方法 |
   | `Hash`               | 允许将类型的值用作哈希表的键                                 | 在类型定义上添加 `#[derive(Hash)]` 或手动实现 `hash` 方法    |
   | `Display`            | 允许格式化输出用户面向的信息                                 | 手动实现 `fmt` 方法                                          |
   | `FromStr`            | 允许从字符串解析出类型的值                                   | 手动实现 `from_str` 方法                                     |
   | `From`/`Into`        | 允许在不同类型之间转换值                                     | 手动实现 `from` 或者 `into` 方法                             |
   | `AsRef`/`AsMut`      | 允许将值转换为引用或可变引用                                 | 手动实现 `as_ref` 或者 `as_mut` 方法                         |
   | `Borrow`/`BorrowMut` | 允许将值借用为引用或可变引用，通常用于哈希表的键和集合元素的比较和查找 | 手动实现 `borrow` 或者 `borrow_mut` 方法                     |
   | `Deref`/`DerefMut`   | 允许重载解引用运算符（*）以便自定义解引用行为。通常用于智能指针 | 手动实现 `deref` 或 `deref_mut` 方法                         |
   | `Iterator`           | 表示一个迭代器，可以迭代产生一系列值，通常用于 for 循环和其他迭代操作。 | 手动实现 `next` 方法                                         |

5. **为何 `Iterator::collect` 依赖 `FromIterator` trait 而非直接构造容器？**

   ```rust
   let nums = vec![1, 2, 3];
   let set: HashSet<_> = nums.into_iter().collect(); // 依赖FromIterator
   ```

   **优势体现**：

   1. **容器无关性**：同一迭代器可生成`Vec`/`HashSet`等
   2. **惰性构造**：迭代过程中逐步构建容器
   3. **零成本抽象**：编译后等价于手写构造代码

6. 为何为自定义 trait/结构体设计 into_inner() 方法？（例如释放内部资源所有权）

7. 举例说明在自定义 trait 中定义并使用关联类型（associated type）的具体场景及方式。（例如实现泛型容器时的类型抽象）

8. 为何 #[derive(Clone)] 对包含引用的结构体可能产生误导？如何手动实现？（深拷贝与浅拷贝的语义差异、生命周期传播）

9. 

10. Trait Objct

11. 详细问了动态分发和静态分发及相关效率影响

12. 解释一下Rust中`Deref` 、`Drop`、`Clone`、`Copy`、`Any` 这几个`trait`
    - `Deref`是解引用语义，结合Rust中的自动解引用机制，可允许自定义包装类型如智能指针等变量像内部变量一样使用，但使用仅限于取`&self`，如果要取`&mut self`则需要`DerefMut`这个`trait`。
    - `Drop`即[析构函数](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=析构函数&zhida_source=entity)。在变量生命周期结束时将自动执行`drop`以销毁。
    - `Clone`是复制语义，可由用户实现，表示复制一个对象。任何可复制的类都可以实现这个`trait`。
    - `Copy`也是复制语义，但与`Clone`不同的是，它只是一个标记，用来告诉编译器，该类型可以直接通过`memcpy`复制，而无需其他动作。`Copy`通常用于原生类型及其组合类型（[结构体](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=结构体&zhida_source=entity)、元组、枚举等）。
    - `Any`提供了一种简单的动态[反射机制](https://zhida.zhihu.com/search?content_id=179681200&content_type=Article&match_order=1&q=反射机制&zhida_source=entity)，要求类型必须具有`'static`的生命周期。在运行时可以`downcast`到任意类型，但若实际类型与要转换的类型不一致时，将返回`Err`。

13. rust优势
    - 内存安全，并发安全，无gc

14. 对Rust函数式编程的理解？C时函数式编程吗？

15. Rust常用的设计模式

16. Rust使用迭代器的好处
    - 惰性

17. Rust的所有权、RAII、借用、生命周期

18. hashmap 和 concurrenthashmap

## 智能指针

1. 了解哪些智能指针？

   - `Box<T>`, `Rc<T>`, `Arc<T>`
   - `Box<T>` 是唯一所有权的指针，无额外开销
   - `Rc<T>` 是线程不安全的共享所有权的指针，由引用计数实现；配套`Weak<T>` 不具有所有权， 只用来跟踪该指针指向的资源是否已被销毁。
   - `Arc<T>`是线程安全的共享所有权的指针，其用法与`Rc<T>`基本相同。

2. 为何 Arc 不直接实现 DerefMut？如何安全地修改其内部数据？（原子引用计数的线程安全限制、Arc<Mutex<T>> 模式）

3. `Rc` 的作用

4. 提到KDTree，父亲孩子相互引用，问 `Rc<T>` 和 `Weak<T>`

5. 举例说明 Cell 与 RefCell 的适用场景及用法区别。（例如内部可变性的编译时与运行时检查）

6. `Cell` 和 `RefCell`
   - 内部可变性

   - `Cell<T>`提供了一种内部可变的机制。可以通过`&self`修改内部的值，而无需通过`&mut self`。它是零开销的，但它的修改只能整体地修改，不能通过`&self`拿到内部的`&mut T`。

     另一种`RefCell<T>`则可以用`borrow`或`borrow_mut`通过`&self`拿到内部的 `&mut T`。但它是有运行时开销的，内部会记录当前的借用状态，是未被借用，还是被可变借用，还是被不可变借用，以及被不可变借用了多少次。

7. `BTreeMap` 的实现
   - B-Tree 是动态数目子节点，有分裂-合并操作的，对有 Cache 的现代 CPU 而言性能更好，比传统二叉树性能更好，因为它一次性拿比较多的数据出来可以填到一个 Cache Line 里

8. `RefCell` 大量使用时是正常现象吗？使用`RefCell` 有什么问题？

   - trait设计不合理，在需要 `&self`的方法上要改变内部状态。使用 `RefCell` 要遵循借用的使用规则，不然会导致运行时Panic

9. 为何 Cow<str> 优于直接使用 String 或 &str 处理混合场景？（借用/拷贝的智能选择、减少不必要的内存分配）

10. 为何 Rc<RefCell<T>> 可能导致运行时死锁？如何用类型系统规避？（内部可变性设计、编译期与运行期检查的权衡）

11. 为何 Box<dyn Error> 作为错误类型时需谨慎？如何设计可追踪的错误链？（trait 对象类型擦除、std::error::Error 的向下兼容性）

## 多线程与并发

1. **`Mutex<T>` 和 `RwLock<T>`** 
   - **对 T 的要求有什么区别？**
     - `Mutex<T>` 要求 `T` 实现 `Send` 和 `Sync`
     - `Rwlock<T>` 要求 `T` 实现 `Send`，通常不要求 `Sync`
   - **`RwLock` 的使用场景？**
     -  最适合用在**并发读多于写的情况**。它允许多个线程同时持有**读锁**，从而实现多个线程可以同时读取数据而不会发生竞争。如果有线程需要写数据，它会**请求写锁并阻塞所有其他的读和写操作**
     - 理想使用场景：共享数据的并发读取、频繁读取，少量写入（如缓存、配置读取、状态监控等场景，读取远远超过写入）
   - **`Mutex` 的使用场景？**
     - 最适合用在**数据写操作比较频繁的情况**。`Mutex` 通过互斥锁确保同一时刻只有一个线程能够访问数据，适用于对数据进行单线程化访问的场景。
     - 理想使用场景：需要频繁修改数据，需要排他锁来保证数据一致性（比如状态更新、批量处理、缓存写入等场景）

2. **锁有几种？说一下锁中毒**

   - Rust 中常见的锁类型：
     - `Mutex<T>` 互斥锁
     - `RwLock<T>` 读写锁
     - `Condvar` 条件变量
     - `Once` 一次性初始化锁
     - `Barrier` 屏障

   - 锁中毒：
     - 定义：当线程在持有锁（如 `Mutex` 或 `RwLock`）时发生 panic，锁会进入“中毒”状态，中毒的锁会记录 panic 信息，其他线程在尝试获取锁时会收到 `PoisonError`
     - 必要性：锁中毒是一种保护机制，用于防止数据处于不一致状态。如果线程在持有锁时 panic，可能会导致共享数据被破坏，锁中毒提醒其他线程数据可能已损坏
     - 处理方案：恢复数据并继续使用锁/丢弃锁并重新初始化数据

3. **用的哪个运行时，`Tokio` 还是 `Async-std`？**

   - 这两个是主流的异步运行时库，都提供了异步 I/O、任务调度、并发工具

   - `Tokio` ：
     - 目标：**高性能**、灵活性、可扩展性
     - 基于 Rust 的异步 I/O 库 `futures  实现的，提供一种高效的异步任务调度机制，从而编写高性能异步应用程序
     - 其核心是一个事件循环，负责监控 I/O 事件，并在事件发生时调度相应的异步任务
     - 最常见的应用场景是处理 I/O 密集型任务，如网络请求、文件读写等，**适合复杂、大规模应用**
     - 拥有丰富的生态，支持多种协议如 HTTP，gRPC，WebSocket
   - `async-std` ：
     - 目标: **提供与 Rust 标准库一致的 API**，降低学习成本
     - 性能略微逊色，调度器使用全局线程池，**适合中小型应用**
     - 提供了很多异步版本的 stdlib 容器，如 `async-std::net`,`async-std::io` 等，更方便地编写异步应用程序，无需手动处理异步任务的调度
     - 最常见的应用场景是与标准库容器（`Vec`, `HashMap`）一起使用
     - 生态较少

4. **为何 `async fn` 返回的 `Future` 默认不实现 `Send`？如何强制标记？**

   - 原因：主要是出于安全性和灵活性的考虑

     - **跨线程安全性**：生成的 `Future` 可能包含非 `Send` 类型（如 `Rc`、裸指针、非 `Send` 的结构体等），如果隐式标记为 `Send`，可能会导致数据竞争或未定义行为（UB），因为非 `Send` 类型可能被多个线程同时访问
     - **灵活性**：默认不实现 `Send` 可以让编译器更灵活地处理 `async fn` 的生成代码。

   - 如果确定 `Future` 是线程安全的，可以这样强制标记：

     - 将 `Future` 装箱并标记为 `Send`

     ```rust
     use std::future::Future;
     use std::pin::Pin;
     
     async fn my_async_fn() -> i32 {
         // 异步代码
         42
     }
     
     fn spawn_send_future() {
         let future: Pin<Box<dyn Future<Output = i32> + Send>> = Box::pin(my_async_fn());
         // 可以将 future 跨线程传递
     }
     ```

     - 约束 `async` 块，显示标记为 `Send`

     ```rust
     use std::future::Future;
     
     fn spawn_send_future() {
         let future: Box<dyn Future<Output = i32> + Send> = Box::pin(async {
             // 异步代码
             42
         });
         // 可以将 future 跨线程传递
     }
     ```

5. **何种场景下选择作用域线程参数（如 `rayon`/`crossbeam`）而非消息传递（如 `std::sync::mpsc` 或 `tokio::sync::mpsc`）？**

   - 作用域线程
     - 特点：在特定作用域内创建线程，并确保线程在作用域结束时全部退出，共享父线程的数据、减少消息传递的开销
     - 场景：
       - **计算密集型任务**（如并行计算、图像处理、科学计算）
       - 临时并行任务（并行初始化数据结构、并行文件处理）
       - 共享不可变数据（并行搜索、并行统计）
       - **复杂的所有权**管理（并行树遍历、图算法）
   - 消息传递
     - 特点：通过 `channel` 在线程间传递数据，具有隔离性、灵活性、安全性
     - 场景：
       - **I/O 密集型任务**
       - 任务间解耦（生产者-消费者模型、事件驱动架构）
       - 长时间运行的任务（网络服务、后台任务）
       - 跨线程通信（多线程服务器、分布式任务）

6. 为何 `rayon` 的快速排序（`quicksort`）优于归并排序（`mergesort`）？反之适用条件？

   - `rayon`：用于并行计算的库，通过**工作窃取调度器**实现高效的并行任务分配，在 `rayon` 中，快排通常由于归并排序，因为快排具有更好的并行化潜力、缓存友好性和更低的空间复杂度
   - 适用场景：
     - 快排：不稳定，**计算密集型任务、通用排序**
     - 归并：需要稳定性、链表排序或外部排序

7. **Rust中的多线程编程 `thread` 和异步编程 `Async`**

   - 这是两种主要的并发模型，各有优缺点，适用于不同的场景
   - `thread`：
     - 特点：
       - 每个任务运行在独立的操作系统线程中
       - 充分利用多核CPU，**适合计算密集型任务**
       - 使用同步原语如 `Mutex`, `Condvar`, `Arc` 等管理共享状态
     - 缺点：
       - 线程的创建和销毁开销较大，**适合长时间运行的任务**
       - 线程间同步复杂，容易引入死锁或竞争条件
   - `Async`：
     - 特点：
       - **基于任务进行调度**，使用异步运行时调度
       - 非阻塞I/O，**适合I/O密集型任务**
       - 更轻量级，可以创建大量并发任务
       - 协作式调度，任务需要主动让出控制权，**适合高并发场景**
     - 缺点：
       - 调试和错误处理更加复杂
       - 需要深入理解异步编程模型

8. **说一下 `async` 和 `Future`**

   - `async` 是关键字，用于定义异步函数或块，能将同步代码转换为异步代码，生成一个 `Future`
   - `Future` 是一个 trait，表示一个异步计算，它可能已经完成（`Poll::Ready`）或仍在进行中（`Poll::Pending`）

9. **什么是 `async` 的优雅关闭？**

   - 指在程序退出时，确保所有异步任务都能正常完成，而不是强制终止。这对于释放资源、保存状态或完成未完成的操作非常重要
   - 如何实现：
     - 监听关闭信号：使用 `tokio::signal` 或 `async-std::signal` 监听系统信号（如 `SIGINT` 或 `SIGTERM`）
     - 通知任务退出：通过通道（channel）或取消标志（`CancellationToken`）通知所有异步任务退出
     - 等待任务完成：使用 `JoinHandle` 或类似机制等待所有任务完成

10. 讲一下 `Send` 和 `Sync`
   - 两个trait，用于保证多线程并发编程的安全性，主要作用是定义类型在多线程环境中的行为约束
   - 多线程编程的时候需要加上，编译器会自己推断一个结构是否 `Send`，是否 `Sync`
   - `Send`：
     - 表示类型的**所有权**可以安全地跨线程传递
     - 类型里的所有子类型需要实现 `Send`
   - `Sync`：
     - 表示类型的**不可变引用**可以安全地跨线程共享
     - 类型里的所有子类型需要实现 `Sync`

11. 多线程好处很多,那Nginx为什么使用多进程而不是多线程?

## 宏

1. **`#[inline(never)]` 的递归优化**

   ```rust
   // 递归函数
   #[inline(never)]
   fn factorial(n: u64) -> u64 {
       if n <= 1 { 1 } else { n * factorial(n-1) }
   }
   ```

   | 策略               | 优点         | 缺点           |
   | :----------------- | :----------- | :------------- |
   | 默认内联           | 减少调用开销 | 栈空间爆炸风险 |
   | `#[inline(never)]` | 控制栈深度   | 增加调用开销   |

2. **`#[repr(C)]` 的FFI必要性**

   ```rust
   #[repr(Rust)] // 默认（编译器可重排字段）
   struct RustStyle {
       a: u8,
       b: u32,
   } // 可能优化为4字节大小
   
   #[repr(C)] // C兼容布局
   struct CStyle {
       a: u8,
       b: u32,
   } // 固定为8字节（含padding）
   ```

   - **字段顺序保证**：C代码依赖固定偏移量
   - **大小和对齐**：跨语言传递时需精确匹配
   - **ABI兼容**：函数调用时的参数传递规则

3. 过程宏

## 错误处理

1. 为何 Rust 的 panic! 不推荐用于常规错误处理？如何设计可恢复的错误策略？（崩溃安全哲学、catch_unwind 的适用边界）

## 其他

1. **何时应避免使用 `BufReader`？**
   - 小文件读取
     - 此时直接读取更高效，否则缓冲区的管理开销可能超过收益
   - 需逐行处理的场景
     - 需要精确控制行边界时，直接处理字符串更可靠

# 八股

1. 

## 操作系统

1. 
3. 协程和线程的区别？什么时候用协程、什么时候用线程？rust为什么没有协程？

   - 其实rust的异步库实现的就是类似协程的东西，协程本质就是task，而且在用户态。应该讲一下用户态和内核态的关系

# 机试

要考虑复杂度

## 简单题

1. **类型转换，`i32`是否可以传给`i64`形参？写一个泛型函数，同时支持`i64`和`i32`形参**

   - 是的，`i32` 可以转换为 `i64`，因为 `i64` 的范围更大，这是一种安全转换只要用 `as i64` （显式转换）或者 `.into()` （隐式转换）即可
   - `Into<i64>` 是一个 trait，表示可以将类型转换为 `i64`，约束泛型参数为 `Into<i64>`，可以同时支持 `i32` 和 `i64`
   - 注册自定义内存分配器（GlobalAlloc）。（例如在特定硬件环境下的内存管理）

   ```rust
   fn function<T: Into<i64>>(value: T) {
       let value_i64: i64 = value.into();
       println!("{}", value_i64);
   }
   
   fn main() {
       let x: i32 = 1;
       let y: i64 = 1;
       function(x);
       function(y);
   }
   ```

2. **写一个结构体，设置默认值并打印它**

   ```rust
   #[derive(Debug)]
   struct A {
       key: i64,
       value: i64,
   }
   
   // 为 A 实现 Default trait
   impl Default for A {
       fn default() -> Self {
           A {
               key: 1,
               value: 2,
           }
       }
   }
   
   fn main() {
       let a = A::default();
       println!("{:?}", a);
   }
   ```

3. 为任意可显示类型（Display）的迭代器定义扩展 trait，实现自定义格式化输出。（例如统一拼接为特定分隔符的字符串）

4. 使用引用计数智能指针（Rc/Arc）建模多对多关系，并使其满足 Sync 约束，最后封装到 Mutex 中。（例如图结构中的节点互引用）

5. 实现自定义哈希器（Hasher）与非默认哈希构建器（BuildHasher），并用于 HashMap 和 HashSet。（仅需展示类型关联，无需关注哈希质量）

6. 为自定义类型实现 FromStr，要求返回自定义错误类型。（例如解析字符串时的结构化错误处理）

7. 编写单元测试用例。（例如对函数边界条件的验证）

## LC题

1. 背包

   直接把输入省了，硬编码了输入去写

   用了 `[Option<i32>; MAX_NUMBER]` 来保存背包，然后用了一些 Rust 的语法特性比如 `Option::map_or` 之类的，反正是写对了

2. n个不同长度有序数组合并为1个有序数组 问思路

   **[Merge k sorted lists](https://leetcode.com/problems/merge-k-sorted-lists/)**

   一开始想的暴力法，后面在提示下联想到归并排序 O(nlogn），算法实现 写了大概二十多分钟

3. 接雨水（没跑出来）

4. 输入一个数列，代表一个地区的高低起伏海拔，计算在潮水退去之后，这个数列代表的“坑洼地”能存放多少水

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-1.png)

5. 两个从右往左的链表实现左对齐的加法

   ![byte-dance-interview-algorithm](https://blog.sbw.so/picture/art-198-2.png)

   6. 写一个函数，接收两个矩形然后输出是否相交，矩形的数据结构自己设计
   7. 俩人轮流丢硬币，谁先扔到正面谁羸。A 先扔，然后问他俩的胜率各是多少
   8. 链表右对齐相加（lc445）
   9. 用栈进行括号匹配
   10. 实现一个 `Future` 的伪代码
   11. （社招）TCP的流处理：
   12. 要求：用户按user_id（ 3-byte ）、payload_len（ 3-byte ）和payload（长度根据前面的定）的格式来发送数据。每个 TCP 连接会源源不断地接收这类格式的消息。
       后面又追加了新的要求：要求限流，每分钟只允许同一个user_id的最多 10 个请求，不同连接都要共享。超过就拒绝。
       之前没有太多网络编程相关的经验，只能凭感觉写了。理清了需求，临时查了 tokio 的文档，就吭哧吭哧就开始写了。面试形式是一边写一边讨论，整个过程花了快 1.5 小时。代码写得很糙，不过需求基本实现了。
   
       最后问，如果服务器长时间运行，那限流使用的类型（我才知道我写的限流算法中的「滑动日志算法」，用一个HashMap维护）中的很多user记录得不到释放，内存会越占用越多。我回答是，用一个定时任务来清空过期的记录。但删除时需要加锁，会阻塞正常的流处理。暂时没有想到好的方法
   
   13. 实现滑动窗口时间限流算法
   
   14. 统计文本文件中单词出现次数，并按频率从高到低输出前10个结果。（例如：文件读取、哈希统计、排序输出）
   

# 时事

1. 对下一代互联网的理解
2. 最近学到的新东西/新技术

# 项目

